<!doctype html>
<html lang="ru">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover"/>
<title>Match-3: –ö—Ä–∏—Å—Ç–∞–ª—å–Ω–∞—è –¥–æ–ª–∏–Ω–∞ ‚Äî Food Edition (Fullscreen)</title>
<style>
  :root{
    --cols:8; --rows:8;
    --gap:6px;
    --board-pad:12px;
    --tile-size:calc((min(540px,100vw) - (var(--gap) * (var(--cols) + 1)) - (var(--board-pad)*2)) / var(--cols));
    --tile-radius:12px;
    --bg1:linear-gradient(180deg,#061426,#02121b);
    --panel:rgba(255,255,255,0.04);
    --accent:#ffd36b;
    --font:-apple-system,BlinkMacSystemFont,"Segoe UI",Roboto,Arial,"Helvetica Neue";
  }
  html,body{height:100%;margin:0;background:var(--bg1);font-family:var(--font);-webkit-font-smoothing:antialiased;color:#eaf6ff}
  /* safe inset top for Telegram header */
  body{padding-top:calc(env(safe-area-inset-top,12px));}
  .app{max-width:640px;margin:0 auto;padding:10px;box-sizing:border-box;min-height:100vh;display:flex;flex-direction:column}
  header{display:flex;align-items:center;justify-content:space-between;gap:12px;padding:6px 0}
  .title{font-weight:700;font-size:18px}
  .subtitle{font-size:12px;color:#9fc7e6}
  .hud{display:flex;gap:10px;align-items:center;justify-content:space-between;margin-bottom:10px}
  .panel{background:var(--panel);padding:10px;border-radius:12px}
  .score{font-weight:700;font-size:20px}
  /* board */
  .board-wrap{display:flex;justify-content:center;flex:1}
  .board{position:relative;padding:var(--board-pad);background:linear-gradient(180deg,#073246,#042a33);border-radius:14px;box-shadow:0 12px 40px rgba(0,0,0,0.6)}
  .grid{position:relative; width: calc(var(--tile-size) * var(--cols) + var(--gap) * (var(--cols) - 1)); height: calc(var(--tile-size) * var(--rows) + var(--gap) * (var(--rows) - 1)); display:block; margin:6px;}
  .cell-slot{position:absolute; width:var(--tile-size); height:var(--tile-size); border-radius:var(--tile-radius); box-sizing:border-box}
  /* tile visuals */
  .tile{position:absolute; width:var(--tile-size); height:var(--tile-size); display:flex;align-items:center;justify-content:center;border-radius:var(--tile-radius); font-size:calc(var(--tile-size) * 0.56); user-select:none;cursor:pointer; transform-origin:center center; transition:transform 260ms cubic-bezier(.22,.9,.3,1), opacity 220ms linear;}
  .emoji{display:inline-block; transform:translateY(2%);}
  .tile.selected{transform:scale(1.08); box-shadow: 0 14px 40px rgba(0,0,0,0.6);}
  .tile.moving{transition:transform 260ms cubic-bezier(.22,.9,.3,1) !important;}
  .tile.removing{animation:popfade 280ms ease forwards;}
  @keyframes popfade{0%{transform:scale(1.06)} 40%{transform:scale(1.28); filter:drop-shadow(0 6px 18px rgba(255,200,120,0.18));} 100%{transform:scale(0.4); opacity:0}}
  /* flash effect overlay */
  .flash {
    position:absolute; pointer-events:none; border-radius:50%; width:60%; height:60%; left:20%; top:20%;
    background: radial-gradient(circle at 30% 30%, rgba(255,240,200,0.9), rgba(255,200,100,0.25) 30%, rgba(255,200,60,0.06) 60%, transparent 70%);
    transform:scale(0); opacity:0; transition:transform 260ms ease, opacity 260ms ease;
  }
  .flash.show{transform:scale(1.4); opacity:1;}
  /* modal */
  .modal{position:fixed;left:50%;top:50%;transform:translate(-50%,-50%);background:#071325;color:#e9fbff;padding:14px;border-radius:12px;display:none;z-index:9999;min-width:260px}
  .modal.show{display:block}
  /* bottom controls */
  footer{padding:8px;text-align:center;color:#9ebedb;font-size:12px;margin-top:10px}
  /* responsive tile-size fallback */
  @media (max-width:520px){
    :root{--tile-size:calc((100vw - 40px - (var(--gap) * 7)) / 8)}
  }
</style>
</head>
<body>
  <div class="app" id="app">
    <header>
      <div>
        <div class="title">Match-3: –ö—Ä–∏—Å—Ç–∞–ª—å–Ω–∞—è –¥–æ–ª–∏–Ω–∞ ‚Äî Food</div>
        <div class="subtitle">Tap ‚Üí Tap. Swap only if match. Fullscreen-ready.</div>
      </div>
      <div style="display:flex;gap:8px;align-items:center">
        <div class="panel small" id="levelBadge">–£—Ä–æ–≤–µ–Ω—å 1</div>
        <button class="panel" id="restartBtn">‚Ü∫</button>
      </div>
    </header>

    <div class="hud">
      <div class="panel">
        <div class="score" id="score">0</div>
        <div style="font-size:12px;color:#9fbfe2">–û—á–∫–∏</div>
      </div>
      <div style="display:flex;flex-direction:column;gap:6px;align-items:flex-end">
        <div class="panel small" id="moves">–•–æ–¥—ã: 30</div>
        <div class="panel small" id="goal">–¶–µ–ª—å: 8000</div>
      </div>
    </div>

    <div class="board-wrap">
      <div class="board" id="board" aria-hidden="false">
        <div class="grid" id="grid"></div>
      </div>
    </div>

    <footer>–°–æ—Ö—Ä–∞–Ω–µ–Ω–∏–µ –ª–æ–∫–∞–ª—å–Ω–æ ‚Ä¢ –ü–æ–¥ fullscreen Mini App</footer>
  </div>

  <div class="modal" id="modal"></div>

<script>
/* Full single-file implementation
 - Selection: tap -> highlight -> tap target -> swap (only if adjacent)
 - Swap anim: move tiles along straight path; if no match -> revert (swap back)
 - Destroy animation: flash + popfade
 - Gravity (Variant B): strict vertical fall, all columns simultaneously, ease-in then ease-out
 - New tiles slide in from above
 - Safe top inset handled in CSS (env(safe-area-inset-top))
 - Emojis: üçéüçìüçáü•êü•¶üßÄüçï
 - Local save via localStorage
*/

const ROWS = 8, COLS = 8;
const EMOJIS = ['üçé','üçì','üçá','ü•ê','ü•¶','üßÄ','üçï'];
const TYPES = EMOJIS.length;
const TILE_GAP = parseInt(getComputedStyle(document.documentElement).getPropertyValue('--gap')) || 6;
const LEVELS = [
  {type:'score', target:8000, moves:30, name:'–õ–µ—Å–Ω–∞—è –ø–æ–ª—è–Ω–∞'},
  {type:'score', target:12000, moves:28, name:'–õ–µ–¥—è–Ω–∞—è –ø–µ—â–µ—Ä–∞'}
];
const STORAGE_KEY = 'match3_food_full_v2';

let state = {
  level: 0,
  score: 0,
  moves: 0,
  lives: 5,
  board: [], // matrix of tiles or null
  selected: null,
  animating: false,
  uid: 1,
  progress: {}
};

const gridEl = document.getElementById('grid');
const boardEl = document.getElementById('board');
const scoreEl = document.getElementById('score');
const movesEl = document.getElementById('moves');
const goalEl = document.getElementById('goal');
const levelBadge = document.getElementById('levelBadge');
const modal = document.getElementById('modal');

function key(r,c){ return r + '_' + c; }
function rand(n){ return Math.floor(Math.random()*n); }
function makeTile(type=null){ return {type: type===null ? rand(TYPES) : type, id: state.uid++}; }

function load(){
  try{
    const raw = localStorage.getItem(STORAGE_KEY);
    if(raw){
      const o = JSON.parse(raw);
      state.level = o.level||0; state.score = o.score||0; state.lives = o.lives||5; state.progress = o.progress||{};
    }
  }catch(e){}
}
function save(){ try{ localStorage.setItem(STORAGE_KEY, JSON.stringify({level:state.level,score:state.score,lives:state.lives,progress:state.progress})); }catch(e){} }

/* compute tile pixel position in grid for row,col */
function tilePos(r,c){
  const tileSize = getTileSize();
  const gap = parseFloat(getComputedStyle(document.documentElement).getPropertyValue('--gap')) || TILE_GAP;
  const x = c * (tileSize + gap);
  const y = r * (tileSize + gap);
  return {x,y};
}
function getTileSize(){
  const tmp = getComputedStyle(document.documentElement).getPropertyValue('--tile-size');
  // try parse numeric pixel if available
  if(tmp && tmp.includes('calc')) {
    // fallback: measure actual grid cell width
    const single = gridEl.getBoundingClientRect().width / COLS - (TILE_GAP * (COLS-1))/COLS;
    return Math.round(single);
  }
  // try parse int
  const px = parseFloat(tmp);
  return px || 48;
}

/* INITIALIZATION */
function initBoard(levelIdx){
  state.board = Array.from({length:ROWS},()=>Array(COLS).fill(null));
  const lvl = LEVELS[levelIdx];
  state.moves = lvl.moves;
  state.score = 0;
  state.selected = null;
  state.animating = false;
  // Fill ensuring no immediate matches
  for(let r=0;r<ROWS;r++){
    for(let c=0;c<COLS;c++){
      let tries=0;
      do{
        state.board[r][c] = makeTile();
        tries++;
        if(tries>100) break;
      } while(immediateMatchAt(r,c));
    }
  }
  renderBoard(true);
  updateHUD();
  save();
}
function immediateMatchAt(r,c){
  const t = state.board[r][c];
  if(!t) return false;
  const v = t.type;
  if(c-1>=0 && c-2>=0 && state.board[r][c-1] && state.board[r][c-2] && state.board[r][c-1].type===v && state.board[r][c-2].type===v) return true;
  if(r-1>=0 && r-2>=0 && state.board[r-1][c] && state.board[r-2][c] && state.board[r-1][c].type===v && state.board[r-2][c].type===v) return true;
  return false;
}

/* RENDER static slots + tiles as absolute elements */
function renderBoard(fast=false){
  // prepare grid slots
  gridEl.innerHTML = '';
  const tileSize = getTileSize();
  const gap = TILE_GAP;
  gridEl.style.width = `calc(var(--tile-size) * ${COLS} + ${gap}px * ${COLS - 1})`;
  gridEl.style.height = `calc(var(--tile-size) * ${ROWS} + ${gap}px * ${ROWS - 1})`;
  // slots (invisible but useful for size)
  for(let r=0;r<ROWS;r++){
    for(let c=0;c<COLS;c++){
      const pos = tilePos(r,c);
      const slot = document.createElement('div');
      slot.className = 'cell-slot';
      slot.style.left = pos.x + 'px';
      slot.style.top = pos.y + 'px';
      slot.dataset.r = r; slot.dataset.c = c;
      gridEl.appendChild(slot);
    }
  }
  // tiles
  for(let r=0;r<ROWS;r++){
    for(let c=0;c<COLS;c++){
      const tile = state.board[r][c];
      if(tile){
        const pos = tilePos(r,c);
        const tdiv = document.createElement('div');
        tdiv.className = 'tile';
        tdiv.dataset.r = r; tdiv.dataset.c = c; tdiv.dataset.id = tile.id;
        tdiv.style.left = pos.x + 'px';
        tdiv.style.top = pos.y + 'px';
        tdiv.style.width = tileSize + 'px';
        tdiv.style.height = tileSize + 'px';
        const em = document.createElement('div'); em.className='emoji'; em.textContent = EMOJIS[tile.type];
        tdiv.appendChild(em);
        // flash overlay (for destroy)
        const flash = document.createElement('div'); flash.className='flash'; tdiv.appendChild(flash);
        // event
        tdiv.addEventListener('click', tileClickHandler);
        if(state.selected && state.selected.r==r && state.selected.c==c) tdiv.classList.add('selected');
        gridEl.appendChild(tdiv);
      }
    }
  }
}

/* find matches (merge overlapping) */
function findMatches(board){
  const groups = [];
  // horizontal
  for(let r=0;r<ROWS;r++){
    let c=0;
    while(c<COLS){
      const t = board[r][c];
      if(!t){ c++; continue; }
      let len=1; const v=t.type;
      for(let k=c+1;k<COLS;k++){ const nt = board[r][k]; if(nt && nt.type===v) len++; else break; }
      if(len>=3){
        const set = new Set();
        for(let k=c;k<c+len;k++) set.add(key(r,k));
        groups.push(set);
      }
      c+=Math.max(1,len);
    }
  }
  // vertical
  for(let c=0;c<COLS;c++){
    let r=0;
    while(r<ROWS){
      const t = board[r][c];
      if(!t){ r++; continue; }
      let len=1; const v=t.type;
      for(let k=r+1;k<ROWS;k++){ const nt = board[k][c]; if(nt && nt.type===v) len++; else break; }
      if(len>=3){
        const set = new Set();
        for(let k=r;k<r+len;k++) set.add(key(k,c));
        groups.push(set);
      }
      r+=Math.max(1,len);
    }
  }
  // merge overlapping sets
  let merged = [];
  for(const s of groups){
    let idx=-1;
    for(let i=0;i<merged.length;i++){
      for(const el of s){ if(merged[i].has(el)){ idx=i; break; } }
      if(idx!=-1) break;
    }
    if(idx!=-1){
      for(const el of s) merged[idx].add(el);
    } else merged.push(new Set([...s]));
  }
  return merged.map(set => Array.from(set).map(k=>{const [r,c]=k.split('_').map(Number); return {r,c};}));
}

/* TILE CLICK */
function tileClickHandler(e){
  if(state.animating) return;
  const el = e.currentTarget;
  const r = +el.dataset.r, c = +el.dataset.c;
  selectCell(r,c);
}

/* SELECTION & SWAP logic: Tap -> select (scale). Tap neighbor -> animate swap, check matches, revert if none. */
function selectCell(r,c){
  if(state.animating) return;
  const tile = state.board[r][c];
  if(!tile) return;
  if(!state.selected){ state.selected = {r,c}; renderSelection(); return; }
  // same tile -> deselect
  if(state.selected.r===r && state.selected.c===c){ state.selected=null; renderSelection(); return; }
  // must be adjacent
  const dr = Math.abs(state.selected.r - r), dc = Math.abs(state.selected.c - c);
  if(dr + dc !== 1){ state.selected = {r,c}; renderSelection(); return; }
  // perform animated swap
  performSwap(state.selected.r, state.selected.c, r, c);
  state.selected = null;
  renderSelection();
}

function renderSelection(){ // update selected class on DOM tiles
  // find all tiles and toggle .selected
  const tiles = gridEl.querySelectorAll('.tile');
  tiles.forEach(t => {
    const tr = +t.dataset.r, tc = +t.dataset.c;
    if(state.selected && state.selected.r===tr && state.selected.c===tc) t.classList.add('selected'); else t.classList.remove('selected');
  });
}

/* Animated swap */
function performSwap(r1,c1,r2,c2){
  if(state.animating) return;
  const elA = gridEl.querySelector('.tile[data-r="'+r1+'"][data-c="'+c1+'"]');
  const elB = gridEl.querySelector('.tile[data-r="'+r2+'"][data-c="'+c2+'"]');
  if(!elA || !elB) return;
  state.animating = true;
  // compute translation
  const rectA = elA.getBoundingClientRect();
  const rectB = elB.getBoundingClientRect();
  const dx = rectB.left - rectA.left;
  const dy = rectB.top - rectA.top;
  // move elements visually
  elA.classList.add('moving'); elB.classList.add('moving');
  elA.style.transform = `translate(${dx}px, ${dy}px)`;
  elB.style.transform = `translate(${-dx}px, ${-dy}px)`;
  // after move, swap state and re-render
  setTimeout(()=>{
    // swap tiles in state
    const tmp = state.board[r1][c1];
    state.board[r1][c1] = state.board[r2][c2];
    state.board[r2][c2] = tmp;
    // clear transforms and re-render (tiles will be recreated)
    state.animating = false;
    renderBoard();
    // check for matches
    const matches = findMatches(state.board);
    if(matches.length>0){
      state.moves--;
      updateHUD();
      processMatchesSequence();
    } else {
      // revert: animate swap back visually (we must get updated DOM elements)
      const aEl2 = gridEl.querySelector('.tile[data-r="'+r2+'"][data-c="'+c2+'"]');
      const bEl2 = gridEl.querySelector('.tile[data-r="'+r1+'"][data-c="'+c1+'"]');
      if(!aEl2 || !bEl2){
        // fallback: just revert state immediately
        const tmp2 = state.board[r1][c1];
        state.board[r1][c1] = state.board[r2][c2];
        state.board[r2][c2] = tmp2;
        renderBoard();
        state.animating = false;
        return;
      }
      const rectA2 = aEl2.getBoundingClientRect(), rectB2 = bEl2.getBoundingClientRect();
      const dx2 = rectB2.left - rectA2.left, dy2 = rectB2.top - rectA2.top;
      // move elements
      state.animating = true;
      aEl2.classList.add('moving'); bEl2.classList.add('moving');
      aEl2.style.transform = `translate(${dx2}px, ${dy2}px)`; // aEl2 moves to b original
      bEl2.style.transform = `translate(${-dx2}px, ${-dy2}px)`;
      setTimeout(()=>{
        // revert state
        const tmp3 = state.board[r1][c1];
        state.board[r1][c1] = state.board[r2][c2];
        state.board[r2][c2] = tmp3;
        renderBoard();
        state.animating = false;
      }, 260);
    }
  }, 260);
}

/* MATCH PROCESSING: destroy animation (flash+pop), then gravity (Variant B: strict vertical), all columns fall simultaneously; new tiles slide in from above */
function processMatchesSequence(){
  if(state.animating) return;
  state.animating = true;
  let chain = 0;
  function step(){
    const matches = findMatches(state.board);
    if(matches.length===0){
      state.animating = false;
      updateHUD();
      checkLevelEnd();
      return;
    }
    chain++;
    // collect positions to remove
    const removal = new Set();
    matches.forEach(g => g.forEach(p => removal.add(key(p.r,p.c))));
    // animate removal: for each tile element, trigger flash & popfade
    for(const k of removal){
      const [r,c] = k.split('_').map(Number);
      const el = gridEl.querySelector('.tile[data-r="'+r+'"][data-c="'+c+'"]');
      if(el){
        const flash = el.querySelector('.flash');
        if(flash){
          flash.classList.add('show');
          setTimeout(()=>flash.classList.remove('show'), 260);
        }
        el.classList.add('removing');
      }
    }
    // scoring
    state.score += removal.size * 80 * chain;
    updateHUD();
    // after pop animation, remove from state and run gravity animation
    setTimeout(()=>{
      // remove tiles from state
      for(const k of removal){
        const [r,c] = k.split('_').map(Number);
        state.board[r][c] = null;
      }
      // animate gravity: compute fall distance for each existing tile and animate transform translateY accordingly
      animateGravity(()=>{ // on gravity complete, next chain after a short pause
        setTimeout(step, 140);
      });
    }, 300); // allow popfade (280ms)
  }
  step();
}

/* animateGravity: strict vertical fall, simultaneous columns.
   For each column, for r from bottom to top, compute how many empty cells below -> target row.
   Animate DOM tiles moving to their new visual y using transform, then commit state and create new tiles from above that slide in.
*/
function animateGravity(callback){
  const tileSize = getTileSize();
  const gap = TILE_GAP;
  // compute new board after gravity (pure state transform)
  const newBoard = Array.from({length:ROWS},()=>Array(COLS).fill(null));
  for(let c=0;c<COLS;c++){
    let write = ROWS - 1;
    for(let r=ROWS-1;r>=0;r--){
      if(state.board[r][c]){
        newBoard[write][c] = state.board[r][c];
        write--;
      }
    }
    // fill rest with new tiles (mark as new with temp negative row)
    for(let r=write;r>=0;r--){
      newBoard[r][c] = makeTile();
      newBoard[r][c]._isNew = true; // mark for slide-in
    }
  }
  // For animation: for existing tiles, compute how many rows they will move down: newRow - oldRow
  const moves = []; // {el, fromR, fromC, toR, toC, dy}
  for(let r=0;r<ROWS;r++){
    for(let c=0;c<COLS;c++){
      const tile = state.board[r][c];
      if(!tile) continue;
      // find new position of this tile (matching by id) in newBoard
      let found=false;
      for(let nr=0;nr<ROWS;nr++){
        if(newBoard[nr][c] && newBoard[nr][c].id === tile.id){
          const dy = (nr - r) * (tileSize + gap);
          moves.push({id:tile.id, fromR:r, toR:nr, c, dy});
          found=true; break;
        }
      }
      if(!found){
        // tile might be consumed (shouldn't happen), ignore
      }
    }
  }
  // Now animate DOM elements corresponding to existing tiles to translateY(dy)
  const domTiles = Array.from(gridEl.querySelectorAll('.tile'));
  // map id->element
  const elById = {};
  domTiles.forEach(el => { elById[el.dataset.id] = el; el.style.transition = 'transform 280ms cubic-bezier(.15,.8,.3,1)'; });
  // apply transforms
  moves.forEach(m=>{
    const el = elById[m.id];
    if(el){
      el.style.transform = `translateY(${m.dy}px)`;
    }
  });
  // For new tiles (those with _isNew true), we need to create DOM elements above the grid and slide them in
  const newEls = [];
  for(let c=0;c<COLS;c++){
    for(let r=0;r<ROWS;r++){
      const t = newBoard[r][c];
      if(t && t._isNew){
        // create element positioned above grid at y = top - (rowsAbove+1) * (tileSize+gap)
        const el = document.createElement('div');
        el.className = 'tile';
        el.dataset.r = r; el.dataset.c = c; el.dataset.id = t.id;
        el.style.width = tileSize + 'px'; el.style.height = tileSize + 'px';
        // start x:
        const pos = tilePos(0,c);
        el.style.left = pos.x + 'px';
        // start above: set top negative by some rows to look like sliding in
        const startOffset = -(tileSize + gap) * (rand(2) + 1); // -1..-2 rows
        el.style.top = (startOffset) + 'px';
        const em = document.createElement('div'); em.className='emoji'; em.textContent = EMOJIS[t.type];
        el.appendChild(em);
        const flash = document.createElement('div'); flash.className='flash'; el.appendChild(flash);
        gridEl.appendChild(el);
        newEls.push({el, toR:r, c});
      }
    }
  }
  // wait small tick, then animate: existing tiles translate to their final positions (we used translateY), new tiles slide down to target y
  requestAnimationFrame(()=>{
    // set transition for newEls
    newEls.forEach(n=>{
      n.el.style.transition = 'top 360ms cubic-bezier(.12,.95,.22,1), transform 360ms';
      const pos = tilePos(n.toR, n.c);
      n.el.style.top = pos.y + 'px';
    });
  });
  // after animation duration, commit state: set state.board = newBoard (without _isNew flags), and re-render
  setTimeout(()=>{
    // remove _isNew
    for(let r=0;r<ROWS;r++) for(let c=0;c<COLS;c++) if(newBoard[r][c] && newBoard[r][c]._isNew) delete newBoard[r][c]._isNew;
    state.board = newBoard;
    renderBoard();
    // small settle delay
    setTimeout(()=>{ if(typeof callback === 'function') callback(); }, 80);
  }, 380);
}

/* HUD and level logic */
function updateHUD(){
  scoreEl.textContent = state.score;
  movesEl.textContent = '–•–æ–¥—ã: ' + state.moves;
  goalEl.textContent = '–¶–µ–ª—å: ' + LEVELS[state.level].target;
  levelBadge.textContent = `–£—Ä–æ–≤–µ–Ω—å ${state.level+1}: ${LEVELS[state.level].name}`;
}

/* Level checks */
function checkLevelEnd(){
  const lvl = LEVELS[state.level];
  if(lvl.type === 'score' && state.score >= lvl.target){
    levelWin(); return;
  }
  if(state.moves <= 0){
    levelFail(); return;
  }
}
function levelWin(){
  const lvl = LEVELS[state.level];
  let stars = 1; const ratio = state.score / lvl.target;
  if(ratio >= 1.6) stars = 3; else if(ratio >= 1.1) stars = 2;
  state.progress[state.level] = Math.max(state.progress[state.level] || 0, stars);
  showModal('–£—Ä–æ–≤–µ–Ω—å –ø—Ä–æ–π–¥–µ–Ω', `–ó–≤–µ–∑–¥—ã: ${stars} ‚Äî –û—á–∫–∏: ${state.score}`, ()=>{
    state.level = Math.min(LEVELS.length-1, state.level+1);
    initBoard(state.level);
    closeModal();
  });
  save();
}
function levelFail(){
  state.lives = Math.max(0, state.lives - 1);
  save();
  if(state.lives <= 0){
    showModal('–ò–≥—Ä–∞ –æ–∫–æ–Ω—á–µ–Ω–∞', '–ñ–∏–∑–Ω–∏ –∫–æ–Ω—á–∏–ª–∏—Å—å ‚Äî —Å–±—Ä–æ—Å –ø—Ä–æ–≥—Ä–µ—Å—Å–∞', ()=>{
      state.level = 0; state.lives = 5; state.progress = {}; initBoard(state.level); closeModal();
    });
  } else {
    showModal('–ü—Ä–æ–≤–∞–ª', '–£—Ä–æ–≤–µ–Ω—å –Ω–µ –ø—Ä–æ–π–¥–µ–Ω ‚Äî –ø–æ—Ç—Ä–∞—á–µ–Ω–∞ –∂–∏–∑–Ω—å', ()=>{ initBoard(state.level); closeModal(); });
  }
}

/* Modal helpers */
function showModal(title, text, onOk){
  modal.innerHTML = `<div style="font-weight:700;margin-bottom:8px">${title}</div><div style="margin-bottom:12px">${text}</div><div style="text-align:right"><button id="modalOk" style="padding:8px 12px;border-radius:8px;background:#0b2f2b;border:none;color:#fff;cursor:pointer">–û–ö</button></div>`;
  modal.classList.add('show');
  document.getElementById('modalOk').onclick = ()=>{ if(onOk) onOk(); else closeModal(); };
}
function closeModal(){ modal.classList.remove('show'); modal.innerHTML=''; }

/* init and events */
load();
initBoard(state.level);

gridEl.addEventListener('click', (e)=>{
  const slot = e.target.closest('.cell-slot');
  if(slot){
    const r = +slot.dataset.r, c = +slot.dataset.c;
    // If clicking on empty slot, ignore
    if(!state.board[r][c]) return;
    selectCell(r,c);
  } else {
    const tileEl = e.target.closest('.tile');
    if(tileEl){
      const r = +tileEl.dataset.r, c = +tileEl.dataset.c;
      selectCell(r,c);
    }
  }
});

document.getElementById('restartBtn').addEventListener('click', ()=>{ if(confirm('–ü–µ—Ä–µ–∑–∞–ø—É—Å—Ç–∏—Ç—å —É—Ä–æ–≤–µ–Ω—å?')) initBoard(state.level); });

/* autosave */
setInterval(save, 5000);

/* expose for debug */
window._m3 = {state, initBoard, renderBoard};

</script>
</body>
</html>

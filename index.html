<!DOCTYPE html>
<html lang="ru">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1.0,maximum-scale=1.0,user-scalable=no" />
<title>–¢—Ä–æ–π–Ω–æ–µ —Å–æ–æ—Ç–≤–µ—Ç—Å—Ç–≤–∏–µ ‚Äî MiniApp</title>
<style>
:root{
  --bg:#071021; --muted:#9ca3af; --accent:#ef4444; --accent-2:#2563eb;
  --tile-gap:6px; --ui-h:66px; --radius:12px; --font-sans:-apple-system,BlinkMacSystemFont,"Segoe UI",Roboto,Arial;
}
html,body{height:100%;margin:0;font-family:var(--font-sans);background:linear-gradient(180deg,#031026,#071021);color:#fff;overflow:hidden;}
.app{display:flex;flex-direction:column;height:100vh;padding:8px;box-sizing:border-box;}
.header{height:var(--ui-h);display:flex;align-items:center;justify-content:space-between;padding:8px;border-radius:10px;background:rgba(255,255,255,0.02);}
.title{font-weight:700;font-size:16px}
.stat{font-size:13px;color:var(--muted)}
.main{flex:1;display:flex;flex-direction:column;align-items:center;justify-content:flex-start;gap:10px;padding-top:4px;}
.grid-wrap{position:relative;width:100%;max-width:900px;flex:1;display:flex;flex-direction:column;align-items:center;justify-content:center;}
.board{position:relative;width:95vw;max-width:820px;background:rgba(255,255,255,0.02);border-radius:14px;padding:10px;box-sizing:border-box;display:flex;align-items:center;justify-content:center;height:calc(100% - 120px);}
.game-grid{display:grid;grid-auto-rows:var(--tile-size);grid-template-columns:repeat(var(--cols), var(--tile-size));gap:var(--tile-gap);width:100%;justify-content:center;align-content:start;position:relative;}
.tile{display:flex;align-items:center;justify-content:center;font-size:calc(var(--tile-size) * 0.5);width:var(--tile-size);height:var(--tile-size);border-radius:10px;background:linear-gradient(180deg,rgba(255,255,255,0.03),rgba(0,0,0,0.06));box-shadow:0 6px 0 rgba(0,0,0,0.35);user-select:none;touch-action:none;position:absolute;transition:transform 360ms cubic-bezier(.2,.9,.2,1), opacity 260ms, box-shadow 220ms;}
.tile .inner{pointer-events:none;}
.tile.empty{opacity:0;transform:scale(0.85);pointer-events:none;}
.tile.selected{outline:3px solid rgba(255,255,255,0.12);transform:scale(1.02);}
.tile.removing{animation:popRemove 320ms ease forwards;opacity:0;}
@keyframes popRemove{0%{transform:scale(1);opacity:1;}60%{transform:scale(1.18);}100%{transform:scale(0.2);opacity:0;}}
.tile.matchGlow{box-shadow:0 0 26px rgba(255,140,60,0.18);transform:scale(1.06);transition:box-shadow 220ms, transform 220ms;}
.canvas-line{position:absolute;left:0;top:0;width:100%;height:100%;pointer-events:none;z-index:60;}
.controls{height:64px;display:flex;align-items:center;justify-content:space-between;padding:6px;margin-top:6px;}
.btn{height:44px;padding:8px 12px;border-radius:10px;background:rgba(255,255,255,0.02);border:1px solid rgba(255,255,255,0.03);color:#fff;display:flex;align-items:center;gap:8px;font-size:15px;}
.goal-bar{display:flex;align-items:center;gap:8px;background:rgba(255,255,255,0.02);padding:8px;border-radius:10px;width:95%;box-sizing:border-box;}
.progress{height:10px;background:rgba(255,255,255,0.04);border-radius:6px;overflow:hidden;flex:1;}
.progress > i{display:block;height:100%;background:linear-gradient(90deg,var(--accent-2),var(--accent));width:0%;}
.hud{display:flex;align-items:center;gap:8px;padding:4px 8px;border-radius:8px;background:rgba(255,255,255,0.02);}
.small{font-size:12px;color:var(--muted);}
.inventory{display:flex;gap:6px;align-items:center;}
.inv-item{padding:6px 8px;border-radius:8px;background:rgba(255,255,255,0.02);font-size:14px;}
/* smooth transition for position changes - we'll animate via transform */
</style>
</head>
<body>
<div class="app" id="app">
  <div class="header">
    <div style="display:flex;gap:10px;align-items:center;">
      <div class="title">–¢—Ä–æ–π–Ω–æ–µ —Å–æ–æ—Ç–≤–µ—Ç—Å—Ç–≤–∏–µ</div>
      <div class="small stat" id="levelLabel">–£—Ä–æ–≤–µ–Ω—å 1</div>
    </div>
    <div style="display:flex;gap:10px;align-items:center;">
      <div class="hud"><div class="small">–û—á–∫–∏</div><div style="font-weight:700;margin-left:6px;" id="score">0</div></div>
      <div class="hud"><div class="small">–í—Ä–µ–º—è</div><div style="font-weight:700;margin-left:6px;" id="timer">--</div></div>
    </div>
  </div>

  <div class="main">
    <div class="grid-wrap" id="gridWrap">
      <div class="board" id="board">
        <div id="grid" class="game-grid" aria-hidden="false"></div>
        <canvas id="lineCanvas" class="canvas-line"></canvas>
      </div>

      <div class="goal-bar" id="goalBar">
        <div id="goalText">–¶–µ–ª—å: —Å–æ–±—Ä–∞—Ç—å 10 —Ç—Ä–æ–µ–∫</div>
        <div class="progress"><i id="goalProgress"></i></div>
        <div class="small" id="goalCount">0/0</div>
      </div>
    </div>

    <div class="controls">
      <button class="btn" id="pauseBtn">‚è∏ –ü–∞—É–∑–∞</button>
      <div style="display:flex;gap:8px;align-items:center;">
        <div class="inventory" id="inventoryBox"></div>
        <button class="btn" id="restartBtn">üîÑ –ü–µ—Ä–µ–∑–∞–ø—É—Å–∫</button>
      </div>
    </div>
  </div>
</div>

<script>
/* =========================
   GameData
   ========================= */
const GameData = {
  levels: [
    { id:1, grid:{rows:6, cols:6}, items:['üçé','üçä','üçå'], goal:{type:'collectTriples', target:10}, timeLimit:120 },
    { id:2, grid:{rows:7, cols:7}, items:['üê∂','üê±','üê≠','üêπ'], goal:{type:'collectSpecific', item:'üê∂', target:15}, timeLimit:150 },
    { id:3, grid:{rows:7, cols:6}, items:['üçá','üçì','üçí','üçê','üçã'], goal:{type:'collectTriples', target:18}, timeLimit:160 },
    { id:4, grid:{rows:6, cols:6}, items:['‚öΩ','üèÄ','üèà','üéæ'], goal:{type:'collectTriples', target:12}, timeLimit:120 },
    { id:5, grid:{rows:8, cols:8},
      items:[
        {id:'apple', states:['üçé','üçè','üçé‚ûú']},
        {id:'flower', states:['üå±','üåø','üåª']},
        {id:'leaf', states:['üçÇ','üçÉ','üçÅ']}
      ],
      goal:{type:'collectTriples', target:20}, timeLimit:210
    }
  ]
};

/* =========================
   LocalStorage keys
   ========================= */
const LS = { currentLevel:'triple_currentLevel', score:'triple_score', inventory:'triple_inventory', settings:'triple_settings' };

/* =========================
   State
   ========================= */
let state = {
  levelIndex:0, rows:6, cols:6, tileSize:56, grid:[], score:0, inventory:{}, settings:{sound:true,music:false},
  selection:[], isTouching:false, timer:null, timeLeft:0, goalProgress:0, removing:false, animating:false
};

/* DOM */
const gridEl = document.getElementById('grid');
const boardEl = document.getElementById('board');
const canvas = document.getElementById('lineCanvas');
const scoreEl = document.getElementById('score');
const levelLabel = document.getElementById('levelLabel');
const timerEl = document.getElementById('timer');
const goalText = document.getElementById('goalText');
const goalProgressEl = document.getElementById('goalProgress');
const goalCountEl = document.getElementById('goalCount');
const inventoryBox = document.getElementById('inventoryBox');

/* Telegram WebApp safe integration */
const tg = (window.Telegram && window.Telegram.WebApp) ? window.Telegram.WebApp : null;
if(tg){ try{ tg.expand(); }catch(e){} try{ if(tg.setHeaderColor) tg.setHeaderColor('#2563eb'); }catch(e){} try{ if(tg.setBackgroundColor) tg.setBackgroundColor('#071021'); }catch(e){} try{ document.body.classList.add((tg.colorScheme||'dark')+'-theme'); }catch(e){} try{ if(tg.BackButton){ tg.BackButton.show(); tg.BackButton.onClick(()=>showLevelSelect()); } }catch(e){} }

/* Utils */
const $ = (s,el=document)=>el.querySelector(s);
const $$ = (s,el=document)=>Array.from(el.querySelectorAll(s));
const rand = (arr)=>arr[Math.floor(Math.random()*arr.length)];
const wait = ms=>new Promise(r=>setTimeout(r,ms));
const genId = ()=>Math.random().toString(36).slice(2,9);

/* Init */
function init(){
  loadSettings(); loadProgress();
  bindUI();
  openLevel(state.levelIndex);
  window.addEventListener('resize', onResize);
  onResize();
  requestAnimationFrame(drawLoop);
}
function bindUI(){
  document.getElementById('pauseBtn').addEventListener('click',togglePause);
  document.getElementById('restartBtn').addEventListener('click',()=>resetLevel(true));
  boardEl.addEventListener('touchstart',onTouchStart,{passive:false});
  boardEl.addEventListener('touchmove',onTouchMove,{passive:false});
  boardEl.addEventListener('touchend',onTouchEnd,{passive:false});
  boardEl.addEventListener('mousedown',onMouseDown);
  document.addEventListener('mousemove',onMouseMove);
  document.addEventListener('mouseup',onMouseUp);
}

/* Persistence */
function saveProgress(){ try{ localStorage.setItem(LS.currentLevel,String(state.levelIndex)); localStorage.setItem(LS.score,String(state.score)); localStorage.setItem(LS.inventory,JSON.stringify(state.inventory)); }catch(e){} }
function loadProgress(){ try{ const lvl=parseInt(localStorage.getItem(LS.currentLevel)); if(!isNaN(lvl)) state.levelIndex=lvl; const sc=parseInt(localStorage.getItem(LS.score)); if(!isNaN(sc)) state.score=sc; const inv=localStorage.getItem(LS.inventory); if(inv) state.inventory=JSON.parse(inv); }catch(e){} }
function loadSettings(){ try{ const s=localStorage.getItem(LS.settings); if(s) state.settings=JSON.parse(s); }catch(e){} }

/* Level handling */
function openLevel(index){
  state.levelIndex = clamp(index,0,GameData.levels.length-1);
  const lvl = GameData.levels[state.levelIndex];
  state.rows = lvl.grid.rows; state.cols = lvl.grid.cols;
  state.grid = Array.from({length:state.rows},()=>Array(state.cols).fill(null));
  state.goalProgress = 0; state.timeLeft = lvl.timeLimit || 120;
  fillInitialGrid(); renderGrid(); updateHeader(); startTimer();
  // after initial fill, apply auto-match until stable to avoid starting matches
  (async ()=>{ while(await findAndResolveMatches(true)); })();
  saveProgress();
}
function fillInitialGrid(){
  const lvl = GameData.levels[state.levelIndex];
  const items = normalizeItems(lvl.items);
  for(let r=0;r<state.rows;r++){
    for(let c=0;c<state.cols;c++){
      state.grid[r][c] = spawn(items);
    }
  }
  // break initial immediate matches simply by shuffling problematic cells
  for(let r=0;r<state.rows;r++){
    for(let c=0;c<state.cols;c++){
      if(r<=state.rows-3){
        if(state.grid[r][c].display === state.grid[r+1][c].display && state.grid[r+1][c].display === state.grid[r+2][c].display){
          state.grid[r+1][c] = spawn(items);
        }
      }
      if(c<=state.cols-3){
        if(state.grid[r][c].display === state.grid[r][c+1].display && state.grid[r][c+1].display === state.grid[r][c+2].display){
          state.grid[r][c+1] = spawn(items);
        }
      }
    }
  }
}
function normalizeItems(items){
  if(!items) return [];
  return items.map(it=>typeof it==='string' ? {type:it,display:it} : {type:it.id,states:it.states});
}
function spawn(items){
  if(items.length===0) return null;
  const pick = rand(items);
  return { type: pick.type, display: pick.display || (pick.states ? rand(pick.states) : pick.type), bonus:null, id:genId() };
}
function clamp(v,a,b){ return Math.max(a,Math.min(b,v)); }

/* Render */
function renderGrid(){
  const cols = state.cols;
  gridEl.style.setProperty('--cols', cols);
  const wrapWidth = document.getElementById('gridWrap').clientWidth - 20;
  const gap = parseInt(getComputedStyle(document.documentElement).getPropertyValue('--tile-gap')) || 6;
  const ts = Math.floor((wrapWidth - (cols-1)*gap - 20) / cols);
  state.tileSize = Math.max(36, Math.min(96, ts));
  gridEl.style.setProperty('--tile-size', state.tileSize + 'px');
  // empty gridEl, create absolute-positioned tiles
  gridEl.innerHTML = '';
  for(let r=0;r<state.rows;r++){
    for(let c=0;c<state.cols;c++){
      const tile = state.grid[r][c];
      const el = document.createElement('div');
      el.className = 'tile';
      el.dataset.r = r; el.dataset.c = c;
      el.style.width = state.tileSize + 'px';
      el.style.height = state.tileSize + 'px';
      const pos = posFor(r,c);
      el.style.left = pos.left + 'px';
      el.style.top = pos.top + 'px';
      el.innerHTML = `<div class="inner">${tile ? tile.display : ''}</div>`;
      if(!tile) el.classList.add('empty');
      if(tile && tile.bonus==='bomb') el.classList.add('bomb');
      gridEl.appendChild(el);
    }
  }
  resizeCanvas();
  updateUI();
}
function posFor(r,c){
  const gap = parseInt(getComputedStyle(document.documentElement).getPropertyValue('--tile-gap')) || 6;
  const left = c * (state.tileSize + gap) + 8;
  const top = r * (state.tileSize + gap) + 8;
  return {left, top};
}
function updateUI(){
  scoreEl.textContent = String(state.score);
  timerEl.textContent = formatTime(state.timeLeft);
  levelLabel.textContent = `–£—Ä–æ–≤–µ–Ω—å ${GameData.levels[state.levelIndex].id}`;
  const lvl = GameData.levels[state.levelIndex];
  if(lvl.goal.type==='collectTriples') goalText.textContent = `–¶–µ–ª—å: —Å–æ–±—Ä–∞—Ç—å ${lvl.goal.target} —Ç—Ä–æ–µ–∫`;
  else goalText.textContent = `–¶–µ–ª—å: —Å–æ–±—Ä–∞—Ç—å ${lvl.goal.target} ${lvl.goal.item}`;
  const target = lvl.goal.target || 0;
  const pct = Math.min(100, (state.goalProgress/target)*100);
  goalProgressEl.style.width = pct + '%';
  goalCountEl.textContent = `${state.goalProgress}/${target}`;
  inventoryBox.innerHTML = '';
  for(const k in state.inventory){ const d=document.createElement('div'); d.className='inv-item'; d.textContent=`${k}√ó${state.inventory[k]}`; inventoryBox.appendChild(d); }
}

/* Timer */
function startTimer(){ stopTimer(); const lvl = GameData.levels[state.levelIndex]; state.timeLeft = lvl.timeLimit || state.timeLeft || 120; timerEl.textContent = formatTime(state.timeLeft); state.timer = setInterval(()=>{ state.timeLeft--; if(state.timeLeft<=0){ state.timeLeft=0; stopTimer(); onTimeExpired(); } updateUI(); },1000); }
function stopTimer(){ if(state.timer){ clearInterval(state.timer); state.timer=null; } }
function togglePause(){ if(state.timer){ stopTimer(); document.getElementById('pauseBtn').textContent='‚ñ∂Ô∏è –ü—Ä–æ–¥–æ–ª–∂–∏—Ç—å'; } else { startTimer(); document.getElementById('pauseBtn').textContent='‚è∏ –ü–∞—É–∑–∞'; } }
function onTimeExpired(){ alert('–í—Ä–µ–º—è –≤—ã—à–ª–æ. –ü–µ—Ä–µ–∑–∞–ø—É—Å–∫ —É—Ä–æ–≤–Ω—è.'); resetLevel(true); }

/* Input handling (touch + mouse), selection drawing */
let inputState = {isDown:false,lastPos:null};
function onTouchStart(e){ e.preventDefault(); const t = e.changedTouches[0]; handlePointerStart({x:t.clientX,y:t.clientY}); }
function onTouchMove(e){ e.preventDefault(); const t = e.changedTouches[0]; handlePointerMove({x:t.clientX,y:t.clientY}); }
function onTouchEnd(e){ e.preventDefault(); handlePointerEnd(); }
function onMouseDown(e){ if(e.button!==0) return; handlePointerStart({x:e.clientX,y:e.clientY}); }
function onMouseMove(e){ if(!inputState.isDown) return; handlePointerMove({x:e.clientX,y:e.clientY}); }
function onMouseUp(e){ if(!inputState.isDown) return; handlePointerEnd(); }

function handlePointerStart(pos){
  inputState.isDown=true; inputState.lastPos=pos; state.selection=[]; state.isTouching=true;
  const tileInfo = getTileAtPos(pos); if(tileInfo) addToSelection(tileInfo.r,tileInfo.c);
}
function handlePointerMove(pos){
  inputState.lastPos=pos; if(!state.isTouching) return;
  const tileInfo = getTileAtPos(pos); if(!tileInfo) return;
  if(state.selection.length===0) addToSelection(tileInfo.r,tileInfo.c);
  else{
    const last = state.selection[state.selection.length-1];
    if(last.r===tileInfo.r && last.c===tileInfo.c) return;
    const idx = state.selection.findIndex(s=>s.r===tileInfo.r && s.c===tileInfo.c);
    if(idx>=0){ state.selection.splice(idx+1); refreshSelectionVisuals(); return; }
    if(isAdjacent(last.r,last.c,tileInfo.r,tileInfo.c)){
      const lastTile = state.grid[last.r][last.c]; const curTile = state.grid[tileInfo.r][tileInfo.c];
      if(lastTile && curTile && lastTile.display===curTile.display && !curTile.bonus){ addToSelection(tileInfo.r,tileInfo.c); }
    }
  }
}
function handlePointerEnd(){ inputState.isDown=false; inputState.lastPos=null; state.isTouching=false; if(state.selection.length>=3) processSelection(); else { state.selection=[]; refreshSelectionVisuals(); } }

function getTileAtPos(pos){
  const rect = gridEl.getBoundingClientRect();
  const x = pos.x - rect.left, y = pos.y - rect.top;
  if(x<0||y<0||x>rect.width||y>rect.height) return null;
  const gap = parseInt(getComputedStyle(document.documentElement).getPropertyValue('--tile-gap'))||6;
  const col = Math.floor(x / (state.tileSize + gap));
  const row = Math.floor(y / (state.tileSize + gap));
  if(row<0||col<0||row>=state.rows||col>=state.cols) return null;
  return {r:row,c:col};
}
function isAdjacent(r1,c1,r2,c2){ return Math.abs(r1-r2)+Math.abs(c1-c2)===1; }
function addToSelection(r,c){
  if(state.selection.find(s=>s.r===r&&s.c===c)) return;
  const tile = state.grid[r][c]; if(!tile) return;
  state.selection.push({r,c}); refreshSelectionVisuals();
}
function refreshSelectionVisuals(){
  $$('.tile').forEach(el=>el.classList.remove('selected'));
  state.selection.forEach(s=>{ const el = tileDom(s.r,s.c); if(el) el.classList.add('selected'); });
}

/* drawing line on canvas */
function resizeCanvas(){ const rect = boardEl.getBoundingClientRect(); canvas.width = Math.round(rect.width * devicePixelRatio); canvas.height = Math.round(rect.height * devicePixelRatio); canvas.style.width = rect.width + 'px'; canvas.style.height = rect.height + 'px'; const ctx = canvas.getContext('2d'); ctx.setTransform(devicePixelRatio,0,0,devicePixelRatio,0,0); }
function drawLoop(){
  const ctx = canvas.getContext('2d'); if(!ctx) return requestAnimationFrame(drawLoop);
  ctx.clearRect(0,0,canvas.width,canvas.height);
  if(state.selection.length>0){
    ctx.lineWidth = 8; ctx.lineCap='round';
    const grad = ctx.createLinearGradient(0,0,canvas.width/canvas.clientWidth,canvas.height/canvas.clientHeight);
    grad.addColorStop(0,'rgba(37,99,235,0.95)'); grad.addColorStop(1,'rgba(239,68,68,0.95)'); ctx.strokeStyle = grad;
    ctx.beginPath();
    for(let i=0;i<state.selection.length;i++){
      const s=state.selection[i]; const p=centerFor(s.r,s.c);
      if(i===0) ctx.moveTo(p.x,p.y); else ctx.lineTo(p.x,p.y);
    }
    if((inputState.isDown || state.isTouching) && inputState.lastPos && state.selection.length>0){
      const rect = gridEl.getBoundingClientRect(); ctx.lineTo(inputState.lastPos.x - rect.left, inputState.lastPos.y - rect.top);
    }
    ctx.stroke();
  }
  requestAnimationFrame(drawLoop);
}
function centerFor(r,c){ const gap = parseInt(getComputedStyle(document.documentElement).getPropertyValue('--tile-gap'))||6; return {x:c*(state.tileSize+gap)+state.tileSize/2+8, y:r*(state.tileSize+gap)+state.tileSize/2+8}; }

/* tile DOM helpers */
function tileDom(r,c){ return gridEl.querySelector(`.tile[data-r="${r}"][data-c="${c}"]`); }

/* Selection processing (user-drawn) */
async function processSelection(){
  if(state.removing || state.animating) return;
  state.removing = true;
  const sel = state.selection.slice();
  const first = state.grid[sel[0].r][sel[0].c];
  if(!first){ state.selection=[]; refreshSelectionVisuals(); state.removing=false; return; }
  const same = sel.every(s=> state.grid[s.r][s.c] && state.grid[s.r][s.c].display === first.display);
  if(!same){ state.selection=[]; refreshSelectionVisuals(); state.removing=false; return; }
  const cnt = sel.length;
  state.score += cnt*10 + (cnt>=4?30:0);
  // animate removal
  for(const s of sel){ const el=tileDom(s.r,s.c); if(el){ el.classList.add('matchGlow'); } }
  await wait(120);
  for(const s of sel){ const el=tileDom(s.r,s.c); if(el){ el.classList.add('removing'); } }
  await wait(320);
  // clear positions
  for(const s of sel) state.grid[s.r][s.c] = null;
  renderGrid(); // render empties
  // gravity + refill with cascade + auto matches loop
  await cascadeAndResolve();
  // goals
  const lvl = GameData.levels[state.levelIndex];
  if(lvl.goal.type==='collectTriples'){ state.goalProgress += 1; } else if(lvl.goal.type==='collectSpecific'){ if(first.display === lvl.goal.item) state.goalProgress += cnt; }
  updateUI(); saveProgress();
  state.selection=[]; refreshSelectionVisuals();
  state.removing=false;
}

/* Find matches anywhere on grid (horizontal/vertical runs >=3) */
function findAllMatches(){
  const matches = []; // array of sets of positions {r,c}
  const mark = Array.from({length:state.rows},()=>Array(state.cols).fill(false));
  // horizontal
  for(let r=0;r<state.rows;r++){
    let run=[0];
    for(let c=0;c<state.cols;c++){
      if(c===0) { run=[0]; continue; }
    }
    // simpler approach: scan
    let start=0;
    while(start<state.cols){
      const tile = state.grid[r][start];
      if(!tile){ start++; continue; }
      let end = start+1;
      while(end<state.cols && state.grid[r][end] && state.grid[r][end].display === tile.display) end++;
      const len = end - start;
      if(len>=3){
        const group=[];
        for(let cc=start;cc<end;cc++){ group.push({r,c:cc}); mark[r][cc]=true; }
        matches.push(group);
      }
      start = end;
    }
  }
  // vertical
  for(let c=0;c<state.cols;c++){
    let start=0;
    while(start<state.rows){
      const tile = state.grid[start][c];
      if(!tile){ start++; continue; }
      let end = start+1;
      while(end<state.rows && state.grid[end][c] && state.grid[end][c].display === tile.display) end++;
      const len = end - start;
      if(len>=3){
        const group=[];
        for(let rr=start;rr<end;rr++){ group.push({r:rr,c}); mark[rr][c]=true; }
        matches.push(group);
      }
      start = end;
    }
  }
  // deduplicate positions into unique list of coords to remove
  const uniqueMap = {};
  matches.forEach(group=> group.forEach(p=> uniqueMap[`${p.r},${p.c}`]=true));
  const unique = Object.keys(uniqueMap).map(k=>{ const [r,c]=k.split(',').map(Number); return {r,c}; });
  return unique.length>0 ? unique : null;
}

/* Resolve matches: animate removal and award points; if just checking during initial fill, optionally just return boolean */
async function findAndResolveMatches(initial=false){
  const matched = findAllMatches();
  if(!matched) return false;
  // mark and animate
  matched.forEach(p=>{ const el = tileDom(p.r,p.c); if(el){ el.classList.add('matchGlow'); } });
  await wait(140);
  matched.forEach(p=>{ const el = tileDom(p.r,p.c); if(el){ el.classList.add('removing'); } });
  await wait(300);
  // remove from logical grid
  matched.forEach(p=>{ state.grid[p.r][p.c] = null; });
  // award points and goals (each match counts as one triple regardless of overlaps)
  const triples = Math.max(1, Math.floor(matched.length/3));
  state.score += matched.length*8;
  state.goalProgress += initial ? 0 : triples;
  renderGrid();
  // gravity + refill with animation
  await cascadeAndResolve();
  return true;
}

/* Cascade: animate falling tiles then refill. After falling, check for new matches (loop). */
async function cascadeAndResolve(){
  state.animating = true;
  await animateGravity();
  // after gravity and refill, check for auto matches; loop until none
  let again = true;
  let safety=0;
  while(again && safety<10){
    again = await findAndResolveMatches(false);
    safety++;
  }
  state.animating = false;
}

/* Animate gravity: compute drop distances per tile, animate transform, then apply logical grid reorder and render */
async function animateGravity(){
  // For each column, compute compacted column and drop distances
  const gap = parseInt(getComputedStyle(document.documentElement).getPropertyValue('--tile-gap'))||6;
  const tileSize = state.tileSize;
  const cols = state.cols, rows = state.rows;
  // create array of DOM elements by r,c for animation
  const domMap = {};
  $$('.tile').forEach(el=>{
    const r = parseInt(el.dataset.r), c = parseInt(el.dataset.c);
    domMap[`${r},${c}`] = el;
    // clear inline transform before starting
    el.style.transition = 'transform 420ms cubic-bezier(.2,.9,.2,1)';
    el.style.willChange = 'transform';
  });

  // compute new columns
  const items = normalizeItems(GameData.levels[state.levelIndex].items);
  const newCols = Array.from({length:cols},()=>[]);
  for(let c=0;c<cols;c++){
    // collect existing tiles bottom->top
    const col = [];
    for(let r=rows-1;r>=0;r--){
      if(state.grid[r][c]) col.push(state.grid[r][c]);
    }
    // number missing
    const miss = rows - col.length;
    // prepend new tiles
    for(let i=0;i<miss;i++) col.push(spawn(items));
    // now col is bottom->top, reverse to top->bottom
    col.reverse();
    newCols[c] = col;
  }

  // compute drop distance for each tile currently present: find its new row index in newCols by matching ids
  const dropMap = {}; // key oldR,oldC -> dyPixels
  for(let c=0;c<cols;c++){
    // build old column list top->bottom
    const oldList = [];
    for(let r=0;r<rows;r++) if(state.grid[r][c]) oldList.push({r,c,id:state.grid[r][c].id,display:state.grid[r][c].display});
    // build new column top->bottom
    const newList = newCols[c];
    // matching by id for those that existed: if not found, it's a new tile (spawned)
    // we'll compute for each old tile where it lands: find index in newList of same id (if exists) or best-effort by display and occurrence
    oldList.forEach(oldTile=>{
      let idx = newList.findIndex(n=>n.id === oldTile.id);
      if(idx===-1){
        // fallback: find first matching display that hasn't been assigned
        idx = newList.findIndex(n=>n.display === oldTile.display && !n._assigned);
      }
      if(idx===-1){
        // give up: it will be removed
        return;
      }
      newList[idx]._assigned = true;
      const newRow = idx;
      const dy = (newRow - oldTile.r) * (tileSize + gap);
      dropMap[`${oldTile.r},${oldTile.c}`] = dy;
    });
  }

  // animate DOM tiles by setting transform
  for(const key in domMap){
    const el = domMap[key];
    const [r,c] = key.split(',').map(Number);
    const dy = dropMap[key] || 0;
    // if dy===0, small settle animation
    if(dy!==0){
      el.style.transform = `translateY(${dy}px)`;
    }else{
      el.style.transform = `translateY(0px)`;
    }
  }

  // wait for transition end (approx)
  await wait(460);

  // remove transitional styles and rebuild state.grid from newCols
  for(let c=0;c<cols;c++){
    for(let r=0;r<rows;r++){
      state.grid[r][c] = newCols[c][r];
      if(state.grid[r][c]) delete state.grid[r][c]._assigned;
    }
  }

  renderGrid();
}

/* Helpers for matches and domino */
function neighbors(r,c){
  const list=[];
  for(let dr=-1;dr<=1;dr++) for(let dc=-1;dc<=1;dc++){ if(dr===0 && dc===0) continue; const nr=r+dr,nc=c+dc; if(nr>=0&&nr<state.rows&&nc>=0&&nc<state.cols) list.push({r:nr,c:nc}); }
  return list;
}

/* findAndResolveMatches used in cascade loop above */

/* Level complete */
function onLevelComplete(){
  stopTimer();
  state.score += 100 * (GameData.levels[state.levelIndex].id);
  alert('–£—Ä–æ–≤–µ–Ω—å –ø—Ä–æ–π–¥–µ–Ω! –û—á–∫–∏: ' + state.score);
  if(state.levelIndex < GameData.levels.length -1){ state.levelIndex++; saveProgress(); openLevel(state.levelIndex); } else { alert('–ü–æ–∑–¥—Ä–∞–≤–ª—è–µ–º! –í—Å–µ —É—Ä–æ–≤–Ω–∏ –ø—Ä–æ–π–¥–µ–Ω—ã.'); saveProgress(); }
}

/* Reset */
function resetLevel(save=false){
  const lvl = GameData.levels[state.levelIndex];
  state.grid = Array.from({length:state.rows},()=>Array(state.cols).fill(null));
  fillInitialGrid();
  renderGrid();
  startTimer();
  state.goalProgress = 0;
  if(save) saveProgress();
}

/* UI small helpers */
function formatTime(sec){ if(sec==null) return '--'; const m=Math.floor(sec/60), s=sec%60; return `${m}:${String(s).padStart(2,'0')}`; }
function updateUI(){ renderGrid(); saveProgress(); }

/* find tile DOM by r,c implemented earlier */
function tileDom(r,c){ return gridEl.querySelector(`.tile[data-r="${r}"][data-c="${c}"]`); }

/* canvas resize and draw loop */
function onResize(){ renderGrid(); }
function resizeCanvas(){ const rect = boardEl.getBoundingClientRect(); canvas.width = Math.round(rect.width * devicePixelRatio); canvas.height = Math.round(rect.height * devicePixelRatio); canvas.style.width = rect.width+'px'; canvas.style.height = rect.height+'px'; const ctx = canvas.getContext('2d'); ctx.setTransform(devicePixelRatio,0,0,devicePixelRatio,0,0); }
function drawLoop(){ const ctx = canvas.getContext('2d'); if(!ctx) return requestAnimationFrame(drawLoop); ctx.clearRect(0,0,canvas.width,canvas.height); if(state.selection.length>0){ ctx.lineWidth=8; ctx.lineCap='round'; const grad=ctx.createLinearGradient(0,0,canvas.width,canvas.height); grad.addColorStop(0,'rgba(37,99,235,0.95)'); grad.addColorStop(1,'rgba(239,68,68,0.95)'); ctx.strokeStyle=grad; ctx.beginPath(); for(let i=0;i<state.selection.length;i++){ const s=state.selection[i]; const p=centerFor(s.r,s.c); if(i===0) ctx.moveTo(p.x,p.y); else ctx.lineTo(p.x,p.y); } if((inputState.isDown||state.isTouching)&&inputState.lastPos&&state.selection.length>0){ const rect=gridEl.getBoundingClientRect(); ctx.lineTo(inputState.lastPos.x - rect.left, inputState.lastPos.y - rect.top); } ctx.stroke(); } requestAnimationFrame(drawLoop); }

/* centerFor used earlier */
function centerFor(r,c){ const gap = parseInt(getComputedStyle(document.documentElement).getPropertyValue('--tile-gap'))||6; return {x:c*(state.tileSize+gap)+state.tileSize/2+8, y:r*(state.tileSize+gap)+state.tileSize/2+8}; }

/* Level selection prompt */
function showLevelSelect(){ const choice = prompt('–í–≤–µ—Å—Ç–∏ –Ω–æ–º–µ—Ä —É—Ä–æ–≤–Ω—è (1..' + GameData.levels.length + ')', String(GameData.levels[state.levelIndex].id)); if(choice!==null){ const num=parseInt(choice); if(!isNaN(num)&&num>=1&&num<=GameData.levels.length){ state.levelIndex=num-1; saveProgress(); openLevel(state.levelIndex); } else alert('–ù–µ–≤–µ—Ä–Ω—ã–π —É—Ä–æ–≤–µ–Ω—å'); } }

/* graceful save */
window.addEventListener('beforeunload',()=>saveProgress());

/* start */
init();

</script>
</body>
</html>

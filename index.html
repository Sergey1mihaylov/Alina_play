<!doctype html>
<html lang="ru">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover"/>
<title>Match-3: –ö—Ä–∏—Å—Ç–∞–ª—å–Ω–∞—è –¥–æ–ª–∏–Ω–∞ ‚Äî Food Edition</title>
<style>
:root{
  --tile-size:calc((min(480px,100vw)-40px)/8);
  --gap:6px;
  --panel:rgba(6,18,32,0.72);
  --glass:#ffffff12;
  --font:-apple-system,BlinkMacSystemFont,"Segoe UI",Roboto,"Helvetica Neue",Arial;
}
*{box-sizing:border-box}
html,body{height:100%;margin:0;font-family:var(--font);background:linear-gradient(180deg,#071029,#021018);color:#e6f7ff}
.app{max-width:480px;margin:12px auto;padding:12px}
.header{display:flex;justify-content:space-between;align-items:center;margin-bottom:8px}
.title{font-weight:700}
.subtitle{font-size:12px;color:#9fbfe2}
.panel{background:var(--panel);padding:10px;border-radius:12px;box-shadow:0 6px 18px rgba(0,0,0,0.45)}
.hud{display:flex;gap:8px;align-items:center;margin-bottom:8px}
.score{font-weight:700;font-size:20px}
.board-wrap{display:flex;justify-content:center}
.board{width:calc(var(--tile-size)*8 + var(--gap)*9);padding:var(--gap);background:linear-gradient(180deg,#083243,#042833);border-radius:12px;display:grid;grid-template-columns:repeat(8, var(--tile-size));grid-auto-rows:var(--tile-size);gap:var(--gap);position:relative}
.cell{position:relative;width:100%;height:100%;background:transparent;border-radius:8px;overflow:visible;touch-action:none}
.tile{position:absolute;left:0;top:0;width:100%;height:100%;display:flex;align-items:center;justify-content:center;border-radius:10px;user-select:none;transition:transform 220ms cubic-bezier(.2,.9,.2,1), opacity 220ms, box-shadow 180ms; font-size:calc(var(--tile-size) * 0.56); will-change:transform,opacity}
.tile .emoji{display:inline-block;transform:translateY(2%)} 
.tile.selected{transform:scale(1.08);box-shadow:0 12px 28px rgba(0,0,0,0.6)}
.tile.anim-move{transition:transform 260ms cubic-bezier(.2,.9,.2,1)}
.tile.removing{transition:transform 220ms ease, opacity 220ms ease; transform:scale(0.4) rotate(-10deg); opacity:0}
.obstacle{position:absolute;left:8%;top:8%;width:84%;height:84%;border-radius:8px;display:flex;align-items:center;justify-content:center;font-size:12px;background:rgba(0,0,0,0.38);color:#fff;padding:4px;text-align:center}
.ice{background:linear-gradient(180deg,#eaf8ff66,#c7f0ff33);border:1px solid rgba(255,255,255,0.06)}
.crate{background:linear-gradient(180deg,#6b4a2b,#4a2f1b)}
.controls{display:flex;gap:8px;align-items:center}
.btn{background:transparent;border:1px solid rgba(255,255,255,0.04);padding:8px 10px;border-radius:10px;color:#dff4ff;cursor:pointer}
.bottom{position:fixed;left:50%;transform:translateX(-50%);bottom:12px;padding:8px 12px;border-radius:20px;background:linear-gradient(180deg,#02131a,#041f2a);box-shadow:0 12px 30px rgba(0,0,0,0.6)}
.modal{position:fixed;left:50%;top:50%;transform:translate(-50%,-50%);background:#071228;padding:16px;border-radius:12px;display:none;z-index:999}
.modal.show{display:block}
.small{font-size:12px;color:#9fbfe2}
.star{width:16px;height:16px;background:linear-gradient(180deg,#fff69a,#ffb84f);border-radius:3px;display:inline-block;margin:0 3px}
@media (max-width:520px){
  :root{--tile-size:calc((100vw - 34px)/8)}
  .app{padding:8px}
}
</style>
</head>
<body>
<div class="app">
  <div class="header">
    <div>
      <div class="title">Match-3: –ö—Ä–∏—Å—Ç–∞–ª—å–Ω–∞—è –¥–æ–ª–∏–Ω–∞ ‚Äî Food Edition</div>
      <div class="subtitle small">Tap ‚Üí Tap to move. Swap only if match; otherwise swap+revert.</div>
    </div>
    <div class="controls">
      <div class="panel small" id="levelBadge">–£—Ä–æ–≤–µ–Ω—å 1</div>
      <button class="btn" id="restart">‚Ü∫</button>
    </div>
  </div>

  <div class="hud panel" style="display:flex;justify-content:space-between;align-items:center;margin-bottom:8px">
    <div>
      <div class="score" id="score">0</div>
      <div class="small">–û—á–∫–∏</div>
    </div>
    <div style="text-align:right">
      <div class="small" id="moves">–•–æ–¥—ã: 30</div>
      <div class="small" id="goal">–¶–µ–ª—å: 8000</div>
    </div>
  </div>

  <div class="board-wrap">
    <div class="board panel" id="board"></div>
  </div>

  <div style="height:90px"></div>

  <div class="bottom panel bottom" id="bottomBar">
    <div style="display:flex;justify-content:space-between;align-items:center;gap:12px">
      <div class="small">–£—Ä–æ–≤–µ–Ω—å <span id="levelNum">1</span></div>
      <div class="small">–ó–≤–µ–∑–¥—ã: <span id="stars"><span class="star" style="opacity:.15"></span><span class="star" style="opacity:.15"></span><span class="star" style="opacity:.15"></span></span></div>
      <div class="small">–ñ–∏–∑–Ω–∏: <span id="lives">‚ù§‚ù§‚ù§‚ù§‚ù§</span></div>
    </div>
  </div>

  <div class="modal" id="modal"></div>
</div>

<script>
/* Single-file match-3 with:
 - select by tap (tile enlarges)
 - second tap swaps (only if adjacent)
 - swap animation; if no match => swap back animation
 - destroy animation (scale + fade)
 - emojis used: üçéüçìüçáü•êü•¶üßÄüçï
 - core match/destroy/gravity logic
*/

// CONFIG
const ROWS = 8, COLS = 8;
const EMOJIS = ['üçé','üçì','üçá','ü•ê','ü•¶','üßÄ','üçï']; // from user
const TYPES = EMOJIS.length;
const LEVELS = [
  {type:'score', target:8000, moves:30, name:'–õ–µ—Å–Ω–∞—è –ø–æ–ª—è–Ω–∞'},
  {type:'score', target:12000, moves:28, name:'–õ–µ–¥—è–Ω–∞—è –ø–µ—â–µ—Ä–∞'}
];
const STORAGE_KEY = 'match3_food_save_v1';

// STATE
let state = {
  level: 0,
  score: 0,
  moves: 0,
  board: [],
  selected: null,
  obstacles: {}, // e.g. "r_c": {type:'ice'|'crate', hits}
  running: true,
  lives: 5,
  levelProgress: {}
};

// UTILS
const boardEl = document.getElementById('board');
function key(r,c){return r+'_'+c}
function rand(n){return Math.floor(Math.random()*n)}
function cloneBoard(b){ return b.map(row => row.map(cell => cell ? {...cell} : null)); }

// SAVE/LOAD
function save(){
  try{
    const payload = {
      level: state.level, score: state.score, lives: state.lives, moves: state.moves, progress: state.levelProgress
    };
    localStorage.setItem(STORAGE_KEY, JSON.stringify(payload));
  }catch(e){}
}
function load(){
  try{
    const raw = localStorage.getItem(STORAGE_KEY);
    if(raw){
      const o = JSON.parse(raw);
      state.level = o.level||0; state.score = o.score||0; state.lives = o.lives||5; state.levelProgress = o.progress||{};
    }
  }catch(e){}
}

/* TILE: {type:0..TYPES-1, id:number} */
let uid=1;
function makeTile(t=null){ return {type: t===null ? rand(TYPES) : t, id: uid++}; }

// INIT BOARD without immediate matches
function initBoard(levelIdx){
  state.board = Array.from({length:ROWS},()=>Array(COLS).fill(null));
  const lvl = LEVELS[levelIdx];
  state.moves = lvl.moves;
  state.score = 0;
  state.selected = null;
  state.obstacles = {}; // demo: none
  // fill ensuring no immediate matches
  for(let r=0;r<ROWS;r++){
    for(let c=0;c<COLS;c++){
      let tries=0;
      do{
        state.board[r][c] = makeTile();
        tries++;
        if(tries>50) break;
      } while(immediateMatchAt(r,c));
    }
  }
  render();
  save();
}
function immediateMatchAt(r,c){
  const t = state.board[r][c];
  if(!t) return false;
  const v = t.type;
  // check left-left and left
  if(c-1>=0 && c-2>=0 && state.board[r][c-1] && state.board[r][c-2] && state.board[r][c-1].type===v && state.board[r][c-2].type===v) return true;
  if(r-1>=0 && r-2>=0 && state.board[r-1][c] && state.board[r-2][c] && state.board[r-1][c].type===v && state.board[r-2][c].type===v) return true;
  return false;
}

// RENDER: create cells and tiles as absolutely positioned elements inside each cell
function render(){
  document.getElementById('score').textContent = state.score;
  document.getElementById('moves').textContent = '–•–æ–¥—ã: ' + state.moves;
  document.getElementById('levelNum').textContent = state.level + 1;
  document.getElementById('levelBadge').textContent = `–£—Ä–æ–≤–µ–Ω—å ${state.level+1}: ${LEVELS[state.level].name}`;
  document.getElementById('goal').textContent = '–¶–µ–ª—å: ' + LEVELS[state.level].target;
  document.getElementById('lives').textContent = '‚ù§'.repeat(state.lives);
  // board DOM
  boardEl.innerHTML = '';
  for(let r=0;r<ROWS;r++){
    for(let c=0;c<COLS;c++){
      const cell = document.createElement('div'); cell.className='cell'; cell.dataset.r=r; cell.dataset.c=c;
      const tile = state.board[r][c];
      if(tile){
        const tdiv = document.createElement('div');
        tdiv.className='tile';
        tdiv.dataset.r = r; tdiv.dataset.c = c; tdiv.dataset.id = tile.id;
        // emoji
        const em = document.createElement('div'); em.className='emoji'; em.textContent = EMOJIS[tile.type];
        tdiv.appendChild(em);
        if(state.selected && state.selected.r==r && state.selected.c==c) tdiv.classList.add('selected');
        // obstacle overlay if any
        const ob = state.obstacles[key(r,c)];
        if(ob){
          const oel = document.createElement('div'); oel.className='obstacle ' + (ob.type==='ice'?'ice':'crate'); oel.textContent = ob.type==='ice'?`–õ—ë–¥ (${ob.hits})`:`–Ø—â–∏–∫ (${ob.hits})`;
          tdiv.appendChild(oel);
        }
        cell.appendChild(tdiv);
      }
      boardEl.appendChild(cell);
    }
  }
}

// MATCH DETECTION
function findMatches(mat){
  const board = mat || state.board;
  const groups = [];
  const used = Array.from({length:ROWS},()=>Array(COLS).fill(false));
  // horizontal
  for(let r=0;r<ROWS;r++){
    let c=0;
    while(c<COLS){
      const t = board[r][c];
      if(!t){ c++; continue; }
      let len=1; const v=t.type;
      for(let k=c+1;k<COLS;k++){ const nt = board[r][k]; if(nt && nt.type===v) len++; else break; }
      if(len>=3){
        const group = [];
        for(let k=c;k<c+len;k++) group.push({r,c:k});
        groups.push(group);
      }
      c+=Math.max(1,len);
    }
  }
  // vertical
  for(let c=0;c<COLS;c++){
    let r=0;
    while(r<ROWS){
      const t = board[r][c];
      if(!t){ r++; continue; }
      let len=1; const v=t.type;
      for(let k=r+1;k<ROWS;k++){ const nt = board[k][c]; if(nt && nt.type===v) len++; else break; }
      if(len>=3){
        const group = [];
        for(let k=r;k<r+len;k++) group.push({r:k,c});
        groups.push(group);
      }
      r+=Math.max(1,len);
    }
  }
  // merge overlapping groups
  const merged = [];
  for(const g of groups){
    const set = new Set(g.map(p=>key(p.r,p.c)));
    let mergedInto = -1;
    for(let i=0;i<merged.length;i++){
      for(const s of merged[i]){
        if(set.has(s)){ mergedInto = i; break; }
      }
      if(mergedInto>=0) break;
    }
    if(mergedInto>=0){
      for(const s of set) merged[mergedInto].add(s);
    } else {
      merged.push(set);
    }
  }
  return merged.map(s=>[...s].map(k=>{const [r,c]=k.split('_').map(Number);return {r,c};}));
}

// SWAP LOGIC with animation and revert if no match
let animating = false;
function canSwap(r1,c1,r2,c2){ const dr=Math.abs(r1-r2), dc=Math.abs(c1-c2); return (dr+dc)===1; }

function getTileElement(r,c){
  return boardEl.querySelector('.tile[data-r="'+r+'"][data-c="'+c+'"]');
}

function animateSwap(r1,c1,r2,c2, onEnd){
  const aEl = getTileElement(r1,c1);
  const bEl = getTileElement(r2,c2);
  if(!aEl || !bEl){ onEnd && onEnd(); return; }
  const aRect = aEl.getBoundingClientRect();
  const bRect = bEl.getBoundingClientRect();
  const dx = bRect.left - aRect.left;
  const dy = bRect.top - aRect.top;
  // apply transforms
  aEl.classList.add('anim-move');
  bEl.classList.add('anim-move');
  aEl.style.transform = `translate(${dx}px, ${dy}px)`;
  bEl.style.transform = `translate(${-dx}px, ${-dy}px)`;
  animating = true;
  setTimeout(()=>{ // after animation
    // clear transforms (we will re-render after state swap)
    aEl.style.transform = '';
    bEl.style.transform = '';
    aEl.classList.remove('anim-move');
    bEl.classList.remove('anim-move');
    animating = false;
    onEnd && onEnd();
  }, 260);
}

function performSwapWithCheck(r1,c1,r2,c2){
  if(animating) return;
  if(!canSwap(r1,c1,r2,c2)) { selectCell(r2,c2); return; }
  const before = cloneBoard(state.board);
  // animate swap visually, then swap state
  animateSwap(r1,c1,r2,c2, ()=>{
    // swap in state
    const tmp = state.board[r1][c1];
    state.board[r1][c1] = state.board[r2][c2];
    state.board[r2][c2] = tmp;
    // update tile dataset positions for DOM correctness: we will simply re-render
    render();
    // check matches
    const matches = findMatches();
    if(matches.length>0){
      state.moves--;
      save();
      // handle matches sequence
      processMatchesSequence();
    } else {
      // no matches: visual swap already happened; now show revert: animate swap back THEN revert state
      setTimeout(()=>{
        // animate swap back elements currently at those positions (rendered)
        animateSwap(r2,c2,r1,c1, ()=>{
          // revert state back
          const t = state.board[r1][c1];
          state.board[r1][c1] = state.board[r2][c2];
          state.board[r2][c2] = t;
          render();
          // small negative audio feedback
        });
      }, 200);
    }
  });
}

// SELECTION HANDLING: tap first -> selected; tap second -> attempt swap (only adjacent)
function selectCell(r,c){
  if(animating) return;
  const tile = state.board[r][c];
  if(!tile) return;
  if(!state.selected){
    state.selected = {r,c};
    render();
    return;
  }
  // if tapped same -> deselect
  if(state.selected.r===r && state.selected.c===c){ state.selected=null; render(); return; }
  // attempt swap only if neighbors
  if(canSwap(state.selected.r,state.selected.c,r,c)){
    performSwapWithCheck(state.selected.r,state.selected.c,r,c);
    state.selected=null;
    render();
  }else{
    // select new cell
    state.selected = {r,c};
    render();
  }
}

// MATCH PROCESSING: remove matches, add score, gravity, spawn new, chain combos
function processMatchesSequence(){
  let chain = 0;
  function step(){
    const matches = findMatches();
    if(matches.length===0){ render(); checkLevelEnd(); return; }
    chain++;
    // gather all cells to remove
    const toRem = new Set();
    for(const g of matches) for(const p of g) toRem.add(key(p.r,p.c));
    // animate removals
    for(const k of toRem){
      const [r,c] = k.split('_').map(Number);
      const el = getTileElement(r,c);
      if(el){ el.classList.add('removing'); }
    }
    // scoring
    state.score += toRem.size * 60 * chain;
    render(); // update score quickly
    // after animation delay, actually clear and drop
    setTimeout(()=>{
      for(const k of toRem){
        const [r,c] = k.split('_').map(Number);
        state.board[r][c] = null;
      }
      gravity();
      // after gravity settle, next chain
      setTimeout(step, 200);
    }, 260);
  }
  step();
}

function gravity(){
  for(let c=0;c<COLS;c++){
    let write = ROWS-1;
    for(let r=ROWS-1;r>=0;r--){
      if(state.board[r][c]){
        if(write !== r){
          state.board[write][c] = state.board[r][c];
          state.board[r][c] = null;
        }
        write--;
      }
    }
    // fill new tiles from top
    for(let r=write;r>=0;r--){
      state.board[r][c] = makeTile();
    }
  }
  render();
}

// LEVEL CHECKS
function checkLevelEnd(){
  const lvl = LEVELS[state.level];
  if(lvl.type==='score'){
    if(state.score >= lvl.target){ levelWin(); return; }
  }
  if(state.moves <= 0){
    levelFail();
  }
}
function levelWin(){
  const lvl = LEVELS[state.level];
  let stars = 1;
  const ratio = state.score / lvl.target;
  if(ratio>=1.6) stars=3; else if(ratio>=1.1) stars=2;
  state.levelProgress[state.level] = Math.max(state.levelProgress[state.level]||0, stars);
  showModal(`–£—Ä–æ–≤–µ–Ω—å –ø—Ä–æ–π–¥–µ–Ω ‚Äî ${stars}‚≠ê`, `–û—á–∫–∏: ${state.score}`, ()=>{
    state.level = Math.min(LEVELS.length-1, state.level+1);
    initBoard(state.level);
    closeModal();
  });
}
function levelFail(){
  state.lives = Math.max(0, state.lives-1);
  save();
  if(state.lives<=0){
    showModal('–ò–≥—Ä–∞ –æ–∫–æ–Ω—á–µ–Ω–∞', '–ñ–∏–∑–Ω–∏ –∫–æ–Ω—á–∏–ª–∏—Å—å. –°–±—Ä–æ—Å –ø—Ä–æ–≥—Ä–µ—Å—Å–∞.', ()=>{
      state.lives = 5; state.level = 0; state.levelProgress = {}; initBoard(state.level); closeModal();
    });
  }else{
    showModal('–ü—Ä–æ–≤–∞–ª', '–£—Ä–æ–≤–µ–Ω—å –Ω–µ –ø—Ä–æ–π–¥–µ–Ω. –ü–æ—Ç—Ä–∞—á–µ–Ω–∞ –∂–∏–∑–Ω—å.', ()=>{ initBoard(state.level); closeModal(); });
  }
}

// INPUT
boardEl.addEventListener('click', (e)=>{
  const cell = e.target.closest('.cell');
  if(!cell) return;
  const r = +cell.dataset.r, c = +cell.dataset.c;
  selectCell(r,c);
});

// RESTART BTN
document.getElementById('restart').addEventListener('click', ()=>{
  if(confirm('–ü–µ—Ä–µ–∑–∞–ø—É—Å—Ç–∏—Ç—å —É—Ä–æ–≤–µ–Ω—å?')) initBoard(state.level);
});

// MODAL
const modal = document.getElementById('modal');
function showModal(title, html, ok){
  modal.innerHTML = `<div style="font-weight:700;margin-bottom:8px">${title}</div><div style="margin-bottom:12px">${html}</div><div style="text-align:right"><button class="btn" id="modalOk">–û–ö</button></div>`;
  modal.classList.add('show');
  document.getElementById('modalOk').onclick = ()=>{ if(ok) ok(); else closeModal(); };
}
function closeModal(){ modal.classList.remove('show'); modal.innerHTML=''; }

// INIT
load();
initBoard(state.level);

/* autosave periodically */
setInterval(()=>save(), 5000);

// expose for debug (optional)
window._m3 = { state, initBoard, save, load };

</script>
</body>
</html>

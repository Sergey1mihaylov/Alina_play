<!doctype html>
<html lang="ru">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover" />
<title>Match-3: –ö—Ä–∏—Å—Ç–∞–ª—å–Ω–∞—è –¥–æ–ª–∏–Ω–∞</title>
<style>
  :root{
    --bg1: linear-gradient(180deg,#0f1724,#071028);
    --panel:#0b1220cc;
    --accent:#ff6b6b;
    --glass:#ffffff22;
    --tile-size:calc((min(480px,100vw)-40px)/8);
    --safe-area-bottom: env(safe-area-inset-bottom, 8px);
    --font-sans: "Inter", "Segoe UI", Roboto, Arial, sans-serif;
  }
  html,body{height:100%;margin:0;font-family:var(--font-sans);background:var(--bg1);color:#e6eef8;-webkit-font-smoothing:antialiased; -moz-osx-font-smoothing:grayscale;}
  .app{max-width:480px;margin:12px auto;padding:12px;box-sizing:border-box;}
  header{display:flex;gap:10px;align-items:center;justify-content:space-between;margin-bottom:8px;}
  .title{font-weight:700;font-size:18px;display:flex;flex-direction:column;line-height:1;}
  .subtitle{font-size:12px;color:#a7c0df}
  .top-controls{display:flex;gap:8px;align-items:center;}
  .btn{background:var(--panel);border-radius:10px;padding:8px 10px;font-size:13px;border:1px solid rgba(255,255,255,0.03);cursor:pointer;color:#eaf6ff}
  .btn.small{padding:6px 8px;font-size:12px;border-radius:8px}
  .hud{display:flex;gap:8px;align-items:center;margin-bottom:8px}
  .panel{background:var(--panel);border-radius:12px;padding:10px;box-shadow:0 6px 18px rgba(0,0,0,0.45);backdrop-filter: blur(6px);}
  .score{font-weight:700;font-size:20px}
  .meta{font-size:12px;color:#9fb9db}
  .board-wrap{display:flex;gap:12px;align-items:flex-start;flex-direction:row;justify-content:center;}
  .board{width:calc(var(--tile-size)*8);height:calc(var(--tile-size)*8);display:grid;grid-template-columns:repeat(8,1fr);grid-auto-rows:var(--tile-size);gap:6px;padding:6px;background:linear-gradient(180deg,#082033,#052033);border-radius:12px;box-shadow:inset 0 2px 8px #0005;}
  .cell{position:relative;width:100%;height:100%;border-radius:8px;overflow:visible;touch-action:none}
  .tile{position:absolute;left:0;top:0;right:0;bottom:0;margin:auto;display:flex;align-items:center;justify-content:center;border-radius:8px;user-select:none;cursor:pointer;transition:transform 180ms cubic-bezier(.2,.9,.2,1), opacity 180ms;}
  .tile .gem{width:76%;height:76%;border-radius:8px;box-shadow:inset 0 6px 12px rgba(255,255,255,0.06), 0 6px 14px rgba(0,0,0,0.45);display:flex;align-items:center;justify-content:center;font-weight:800;color:#fff;text-shadow:0 1px 0 rgba(0,0,0,0.6)}
  /* gem colors */
  .gem.g1{background:linear-gradient(180deg,#ff5b5b,#c73a3a)}
  .gem.g2{background:linear-gradient(180deg,#4f9dff,#2a6fc7)}
  .gem.g3{background:linear-gradient(180deg,#49d46f,#1b9a4a)}
  .gem.g4{background:linear-gradient(180deg,#cd7cff,#8d3fbf)}
  .gem.g5{background:linear-gradient(180deg,#ffd36b,#d08a2c)}
  .gem.g6{background:linear-gradient(180deg,#d6f7ff,#7fd7ea);color:#08464f}
  /* special markers */
  .tile .mark{position:absolute;right:4px;top:4px;font-size:11px;padding:2px 5px;border-radius:6px;background:#0006}
  .tile.selected{transform:scale(1.06) rotate(-2deg);z-index:5;box-shadow:0 10px 30px rgba(0,0,0,0.6)}
  .tile.removing{opacity:0;transform:scale(.6) rotate(8deg)}
  .obstacle{position:absolute;left:8%;top:8%;width:84%;height:84%;border-radius:6px;display:flex;align-items:center;justify-content:center;font-size:12px;background:rgba(0,0,0,0.32);color:#fff;padding:4px;text-align:center}
  .ice{background:linear-gradient(180deg,#dff6ff44,#9ddbf444);border:2px solid rgba(255,255,255,0.06);box-shadow:inset 0 4px 8px rgba(255,255,255,0.06)}
  .crate{background:linear-gradient(180deg,#7a4b2b,#5a341f);box-shadow:inset 0 6px 8px rgba(0,0,0,0.3)}
  .controls{display:flex;flex-direction:column;gap:8px;}
  .side-panel{min-width:140px;display:flex;flex-direction:column;gap:8px}
  .goal{font-size:13px}
  .bottom-nav{position:fixed;left:50%;transform:translateX(-50%);bottom:calc(var(--safe-area-bottom) + 8px);width:calc(min(480px,100vw) - 24px);display:flex;justify-content:space-between;align-items:center;padding:10px;border-radius:24px;background:linear-gradient(180deg,#082135,#021122);box-shadow:0 10px 30px rgba(0,0,0,0.6)}
  .nav-btn{background:transparent;border:none;color:#cfeaff;font-weight:600;padding:8px 10px;border-radius:18px;cursor:pointer}
  .smalltext{font-size:12px;color:#9fb9db}
  .row{display:flex;gap:8px;align-items:center}
  .stars{display:flex;gap:4px}
  .star{width:18px;height:18px;background:linear-gradient(180deg,#fff69a,#ffb84f);border-radius:4px;box-shadow:0 2px 6px rgba(0,0,0,0.4)}
  .overlay{position:fixed;left:0;top:0;width:100%;height:100%;display:none;align-items:center;justify-content:center;padding:20px;box-sizing:border-box}
  .overlay.show{display:flex}
  .modal{background:#07142a;color:#e6f6ff;padding:16px;border-radius:12px;max-width:420px;width:100%;box-shadow:0 10px 40px rgba(0,0,0,0.6)}
  .modal h2{margin:0 0 8px;font-size:18px}
  .modal p{margin:8px 0}
  .level-badge{font-size:13px;padding:6px 8px;border-radius:10px;background:#031826;color:#bfe6ff}
  footer{color:#9fb9db;font-size:12px;text-align:center;margin-top:12px}
  @media (max-width:520px){
    :root{--tile-size:calc((100vw - 34px)/8)}
    .app{padding:8px;margin:8px}
  }
</style>
</head>
<body>
<div class="app">
  <header>
    <div class="title">
      <div>Match-3: –ö—Ä–∏—Å—Ç–∞–ª—å–Ω–∞—è –¥–æ–ª–∏–Ω–∞</div>
      <div class="subtitle">–Ø—Ä–∫–∏–µ –∫—Ä–∏—Å—Ç–∞–ª–ª—ã, —É—Ä–æ–≤–Ω–∏ –∏ –∫–æ–º–±–æ</div>
    </div>
    <div class="top-controls">
      <div class="level-badge panel" id="levelBadge">–£—Ä–æ–≤–µ–Ω—å 1</div>
      <button class="btn small" id="soundToggle">üîä</button>
      <button class="btn small" id="menuBtn">‚ò∞</button>
    </div>
  </header>

  <div class="hud">
    <div class="panel" style="flex:1">
      <div class="row" style="justify-content:space-between">
        <div>
          <div class="score" id="score">0</div>
          <div class="smalltext">–û—á–∫–∏</div>
        </div>
        <div style="text-align:right">
          <div class="meta" id="movesOrTimer">–•–æ–¥—ã: 30</div>
          <div class="smalltext" id="goalText">–¶–µ–ª—å: 10000 –æ—á–∫–æ–≤</div>
        </div>
      </div>
    </div>

    <div class="panel side-panel">
      <div class="goal"><strong>–¶–µ–ª—å</strong><div id="goalList">–ù–∞–±—Ä–∞—Ç—å 10000 –æ—á–∫–æ–≤</div></div>
      <div class="row">
        <div class="smalltext">–ñ–∏–∑–Ω–∏</div>
        <div id="lives" style="margin-left:auto">‚ù§‚ù§‚ù§‚ù§‚ù§</div>
      </div>
      <div class="row">
        <div class="smalltext">–ë—É—Å—Ç–µ—Ä—ã</div>
        <div style="margin-left:auto" id="boosts">
          <button class="btn small" data-boost="hammer">–ú–æ–ª–æ—Ç</button>
          <button class="btn small" data-boost="shuffle">–ü–µ—Ä–µ–º–µ—à–∞—Ç—å</button>
        </div>
      </div>
    </div>
  </div>

  <div class="board-wrap">
    <div class="board panel" id="board"></div>
  </div>

  <div class="bottom-nav" role="navigation">
    <div style="display:flex;gap:8px;align-items:center">
      <button class="nav-btn" id="restartBtn">‚Ü∫ –ü–µ—Ä–µ–∑–∞–ø—É—Å—Ç–∏—Ç—å</button>
      <button class="nav-btn" id="pauseBtn">‚è∏ –ü–∞—É–∑–∞</button>
    </div>
    <div style="display:flex;gap:8px;align-items:center">
      <div class="smalltext">–£—Ä–æ–≤–µ–Ω—å <span id="levelNum">1</span></div>
      <div class="stars" id="starBox">
        <div class="star" style="opacity:.15"></div>
        <div class="star" style="opacity:.15"></div>
        <div class="star" style="opacity:.15"></div>
      </div>
    </div>
  </div>

  <footer>–°–æ—Ö—Ä–∞–Ω–µ–Ω–∏–µ –ø—Ä–æ–≥—Ä–µ—Å—Å–∞: –ª–æ–∫–∞–ª—å–Ω–æ. –í–µ—Ä—Å–∏—è –º–∏–Ω–∏-–¥–µ–º–æ.</footer>
</div>

<!-- Overlays -->
<div class="overlay" id="overlay">
  <div class="modal" id="modalContent"></div>
</div>

<script>
/* Match-3: –ö—Ä–∏—Å—Ç–∞–ª—å–Ω–∞—è –¥–æ–ª–∏–Ω–∞ ‚Äî single-file implementation.
   Features included (minimal, functional):
   - 8x8 grid, 6 gem types
   - swap by tap or drag
   - matches resolved, tiles fall down, new tiles spawn
   - combos and scoring, chain multiplier
   - special tiles: striped (row/col), bomb (radius), color-bomb
   - obstacles: crate (1 hit), ice (needs break)
   - levels with targets (points / clear obstacles)
   - stars (1-3), lives, boosters (hammer/shuffle), pause/restart
   - progress saved to localStorage
   - simple WebAudio feedback (toggleable)
*/

/* ---------- CONFIG ---------- */
const ROWS = 8, COLS = 8;
const GEM_TYPES = 6;
const TILE_GAP = 6;
const START_LIVES = 5;

/* Level data (demo set). Each level: {type:'score'|'clear', target: number, moves: number, obstacles:Array of {r,c,type,hits}} */
const LEVELS = [
  {type:'score', target:8000, moves:30, name:'–õ–µ—Å–Ω–∞—è –ø–æ–ª—è–Ω–∞', obstacles:[]},
  {type:'score', target:12000, moves:28, name:'–õ–µ–¥—è–Ω–∞—è –ø–µ—â–µ—Ä–∞', obstacles:[
    // ice in some positions
    {r:2,c:3,type:'ice',hits:1},{r:2,c:4,type:'ice',hits:1},{r:3,c:4,type:'ice',hits:1},
  ]},
  {type:'clear', target:8, moves:32, name:'–í—É–ª–∫–∞–Ω–∏—á–µ—Å–∫–æ–µ —É—â–µ–ª—å–µ', obstacles:[
    {r:4,c:4,type:'crate',hits:2},{r:5,c:3,type:'crate',hits:2}
  ]},
  {type:'score', target:18000, moves:25, name:'–°–≤–µ—Ä–∫–∞—é—â–∏–µ –ø–µ—â–µ—Ä—ã', obstacles:[]},
  {type:'score', target:24000, moves:22, name:'–ó–∞—Ç–µ—Ä—è–Ω–Ω—ã–π –æ–∞–∑–∏—Å', obstacles:[
    {r:1,c:1,type:'ice',hits:1},{r:1,c:2,type:'crate',hits:2}
  ]},
  // later levels repeat pattern ‚Äî more can be added externally
];

const STORAGE_KEY = 'match3_save_v1';

/* ---------- STATE ---------- */
let state = {
  levelIndex: 0,
  score: 0,
  lives: START_LIVES,
  levelProgress: {}, // stars per level
  board: [], // matrix of tile objects
  obstacles: {}, // key "r_c" => obstacle data
  movesLeft: 0,
  running: true,
  selected: null,
  combos: 0,
  soundOn: true,
  boosts: {hammer:1,shuffle:1},
  lastSave: Date.now()
};

/* ---------- AUDIO ---------- */
let audioCtx;
function ensureAudio(){
  if(!audioCtx) audioCtx = new (window.AudioContext || window.webkitAudioContext)();
}
function beep(freq=440,dur=0.06,vol=0.06){
  if(!state.soundOn) return;
  ensureAudio();
  const o = audioCtx.createOscillator();
  const g = audioCtx.createGain();
  o.type='sine'; o.frequency.value = freq;
  g.gain.value = vol;
  o.connect(g); g.connect(audioCtx.destination);
  o.start(); g.gain.exponentialRampToValueAtTime(0.0001, audioCtx.currentTime + dur);
  setTimeout(()=>o.stop(), dur*1000 + 30);
}

/* ---------- UTIL ---------- */
function key(r,c){return r+'_'+c}
function randInt(n){return Math.floor(Math.random()*n)}
function shuffleArray(a){for(let i=a.length-1;i>0;i--){const j=Math.floor(Math.random()*(i+1));[a[i],a[j]]=[a[j],a[i]];} return a;}

/* ---------- SAVE / LOAD ---------- */
function saveProgress(){
  try{
    localStorage.setItem(STORAGE_KEY, JSON.stringify({
      levelIndex: state.levelIndex,
      score: state.score,
      lives: state.lives,
      levelProgress: state.levelProgress,
      boosts: state.boosts,
      lastSave: Date.now()
    }));
    state.lastSave = Date.now();
    //console.log('saved');
  }catch(e){console.warn('save failed',e)}
}
function loadProgress(){
  try{
    const raw = localStorage.getItem(STORAGE_KEY);
    if(raw){const o = JSON.parse(raw); if(o){ state.levelIndex = o.levelIndex||0; state.score = o.score||0; state.lives = o.lives||START_LIVES; state.levelProgress = o.levelProgress||{}; state.boosts = o.boosts||state.boosts; }}
  }catch(e){console.warn('load failed', e)}
}

/* ---------- BOARD / TILES ---------- */
/* Tile format:
 {type: 0..GEM_TYPES-1, special: null|'stripH'|'stripV'|'bomb'|'color', id:unique}
 Obstacles stored separately with keys r_c -> {type:'ice'|'crate', hits:int}
*/
let uidCounter=1;
function makeTile(type=null){
  return {type: type===null?randInt(GEM_TYPES):type, special:null, id:uidCounter++};
}

/* Initialize board with no immediate matches */
function initBoard(levelIdx){
  state.board = Array.from({length:ROWS},()=>Array(COLS).fill(null));
  // place obstacles
  state.obstacles = {};
  const lvl = LEVELS[levelIdx];
  if(lvl && lvl.obstacles) for(const ob of lvl.obstacles) state.obstacles[key(ob.r,ob.c)] = {type:ob.type,hits:ob.hits||1};
  // fill ensuring no immediate matches
  for(let r=0;r<ROWS;r++){
    for(let c=0;c<COLS;c++){
      let tries=0, t;
      do{
        t = makeTile();
        state.board[r][c] = t;
        tries++;
        if(tries>50) break;
      } while(checkImmediateMatchAt(r,c));
    }
  }
  state.movesLeft = lvl.moves;
  state.score=0;
  state.combos=0;
  state.selected = null;
  renderAll();
}

/* returns true if placing tile at r,c causes immediate match */
function checkImmediateMatchAt(r,c){
  const t = state.board[r][c];
  if(!t) return false;
  const v = t.type;
  // horizontal
  let count=1;
  if(c-1>=0 && state.board[r][c-1] && state.board[r][c-1].type===v) count++;
  if(c-2>=0 && state.board[r][c-2] && state.board[r][c-2].type===v) count++;
  if(count>=3) return true;
  // vertical
  count=1;
  if(r-1>=0 && state.board[r-1][c] && state.board[r-1][c].type===v) count++;
  if(r-2>=0 && state.board[r-2][c] && state.board[r-2][c].type===v) count++;
  return count>=3;
}

/* ---------- RENDER ---------- */
const boardEl = document.getElementById('board');
function renderAll(){
  document.getElementById('score').textContent = state.score;
  document.getElementById('levelNum').textContent = state.levelIndex + 1;
  document.getElementById('levelBadge').textContent = `–£—Ä–æ–≤–µ–Ω—å ${state.levelIndex+1}: ${LEVELS[state.levelIndex].name || ''}`;
  document.getElementById('movesOrTimer').textContent = `–•–æ–¥—ã: ${state.movesLeft}`;
  const gtxt = LEVELS[state.levelIndex].type === 'score' ? `–ù–∞–±—Ä–∞—Ç—å ${LEVELS[state.levelIndex].target}` : `–£–Ω–∏—á—Ç–æ–∂–∏—Ç—å: ${LEVELS[state.levelIndex].target}`;
  document.getElementById('goalList').textContent = gtxt;
  document.getElementById('goalText').textContent = `–¶–µ–ª—å: ${gtxt}`;
  document.getElementById('lives').textContent = '‚ù§'.repeat(Math.max(0, state.lives));

  // stars
  const stars = document.getElementById('starBox').children;
  const sc = state.levelProgress[state.levelIndex] || 0;
  for(let i=0;i<3;i++) stars[i].style.opacity = i<sc ? '1' : '.15';

  // render grid
  boardEl.innerHTML = '';
  for(let r=0;r<ROWS;r++){
    for(let c=0;c<COLS;c++){
      const cell = document.createElement('div');
      cell.className='cell';
      cell.dataset.r=r; cell.dataset.c=c;
      const tile = state.board[r][c];
      if(tile){
        const tdiv = document.createElement('div');
        tdiv.className = 'tile';
        tdiv.dataset.id = tile.id;
        tdiv.dataset.r = r; tdiv.dataset.c = c;
        if(state.selected && state.selected.r==r && state.selected.c==c) tdiv.classList.add('selected');
        // inner gem
        const gem = document.createElement('div');
        gem.className = 'gem g'+(tile.type+1);
        gem.textContent = tile.special==='color'?'‚òÖ': '';
        if(tile.special === 'stripH' || tile.special === 'stripV' || tile.special==='bomb'){
          const mark = document.createElement('div'); mark.className='mark'; 
          mark.textContent = tile.special==='stripH'?'‚îÅ':(tile.special==='stripV'?'‚îÉ': (tile.special==='bomb'?'‚ú∂':'')); 
          tdiv.appendChild(mark);
        }else if(tile.special==='color'){
          const mark = document.createElement('div'); mark.className='mark'; mark.textContent='‚ú¶'; tdiv.appendChild(mark);
        }
        tdiv.appendChild(gem);
        // obstacles overlay
        const ob = state.obstacles[key(r,c)];
        if(ob){
          const oel = document.createElement('div'); oel.className='obstacle';
          oel.textContent = ob.type==='ice' ? `–õ—ë–¥ (${ob.hits})` : `–Ø—â–∏–∫ (${ob.hits})`;
          oel.classList.add(ob.type==='ice'?'ice':'crate');
          tdiv.appendChild(oel);
        }
        cell.appendChild(tdiv);
      }
      boardEl.appendChild(cell);
    }
  }
}

/* ---------- MATCH DETECTION ---------- */
function findMatches(){
  const matches = []; // array of arrays of {r,c}
  const used = Array.from({length:ROWS},()=>Array(COLS).fill(false));
  // horizontal
  for(let r=0;r<ROWS;r++){
    let c=0;
    while(c<COLS){
      const t = state.board[r][c];
      if(!t){ c++; continue; }
      let len=1; const v=t.type;
      for(let k=c+1;k<COLS;k++){
        const nt = state.board[r][k];
        if(nt && nt.type===v) len++; else break;
      }
      if(len>=3){
        const arr=[];
        for(let k=c;k<c+len;k++){ arr.push({r,col:k}); used[r][k]=true; }
        matches.push(arr);
      }
      c+=Math.max(1,len);
    }
  }
  // vertical
  for(let c=0;c<COLS;c++){
    let r=0;
    while(r<ROWS){
      const t = state.board[r][c];
      if(!t){ r++; continue; }
      let len=1; const v=t.type;
      for(let k=r+1;k<ROWS;k++){
        const nt = state.board[k][c];
        if(nt && nt.type===v) len++; else break;
      }
      if(len>=3){
        const arr=[];
        for(let k=r;k<r+len;k++){ arr.push({r:k,col:c}); used[k][c]=true; }
        matches.push(arr);
      }
      r+=Math.max(1,len);
    }
  }
  // merge overlapping groups into bigger ones
  // naive merge: create map and union groups that share a cell
  const groups = [];
  for(const m of matches){
    // convert to key set
    const set = new Set(m.map(x=>key(x.r,x.col)));
    groups.push(set);
  }
  let merged=true;
  while(merged){
    merged=false;
    for(let i=0;i<groups.length;i++){
      for(let j=i+1;j<groups.length;j++){
        for(const kcell of groups[j]){
          if(groups[i].has(kcell)){
            // merge j into i
            for(const el of groups[j]) groups[i].add(el);
            groups.splice(j,1);
            merged=true; break;
          }
        }
        if(merged) break;
      }
      if(merged) break;
    }
  }
  // convert to arrays of positions
  return groups.map(s=>[...s].map(k=>{const [r,c]=k.split('_').map(Number); return {r,c};}));
}

/* ---------- SWAP ---------- */
function canSwap(r1,c1,r2,c2){
  if(r1<0||r1>=ROWS||r2<0||r2>=ROWS||c1<0||c1>=COLS||c2<0||c2>=COLS) return false;
  const dr = Math.abs(r1-r2), dc=Math.abs(c1-c2);
  return (dr+dc)===1;
}

/* Perform swap and check if it creates a match; returns true if swap resulted in any match */
function doSwap(r1,c1,r2,c2,force=false){
  if(!canSwap(r1,c1,r2,c2)) return false;
  const a = state.board[r1][c1], b=state.board[r2][c2];
  if(!a || !b) return false;
  // swap
  state.board[r1][c1]=b; state.board[r2][c2]=a;
  // if forced (power activation), accept regardless
  const matches = findMatches();
  if(matches.length>0 || force){
    playSwapAnim(r1,c1,r2,c2);
    state.movesLeft--;
    processMatchesSequence();
    return true;
  }else{
    // revert with small animation
    setTimeout(()=>{ state.board[r1][c1]=a; state.board[r2][c2]=b; renderAll(); }, 160);
    return false;
  }
}

/* ---------- MATCH RESOLUTION & FALL ---------- */
function processMatchesSequence(){
  let chain = 0;
  function step(){
    const matches = findMatches();
    if(matches.length===0){
      state.combos = chain;
      renderAll();
      checkLevelEnd();
      return;
    }
    chain++;
    // mark tiles to remove, calculate score, generate special tiles if applicable
    const toRemove = new Set();
    let createdSpecials = []; // {r,c, kind}
    for(const g of matches){
      // score: base 60 per tile * chain multiplier
      const baseScore = 60 * g.length * chain;
      state.score += baseScore;
      // detect if match length implies a special
      // if 4 in a row -> striped, if >=5 -> color bomb, if L/T -> bomb
      // detect shape by checking rows and cols counts
      const rows = new Set(g.map(x=>x.r));
      const cols = new Set(g.map(x=>x.c));
      // find if it's line or L/T: if more than one row and more than one col -> L/T shape
      if(g.length>=5){
        // create color bomb at first tile
        const pos = g[Math.floor(g.length/2)];
        createdSpecials.push({r:pos.r,c:pos.c,kind:'color'});
      } else if(rows.size===1 || cols.size===1){
        if(g.length===4){
          // create striped along direction
          const pos = g[Math.floor(g.length/2)];
          const kind = rows.size===1 ? 'stripH' : 'stripV';
          createdSpecials.push({r:pos.r,c:pos.c,kind});
        }
      } else {
        // L/T
        const pos = g[Math.floor(g.length/2)];
        createdSpecials.push({r:pos.r,c:pos.c,kind:'bomb'});
      }
      for(const p of g) toRemove.add(key(p.r,p.c));
    }
    // remove tiles (but don't remove if obstacle below prevents removal ‚Äî here obstacles are on tile and are removed when matched beside)
    // For simplicity: removing a tile also damages obstacle at same spot (reduces hits).
    for(const k of toRemove){
      const [r,c] = k.split('_').map(Number);
      const ob = state.obstacles[k];
      if(ob){
        ob.hits--;
        if(ob.hits<=0) delete state.obstacles[k];
      }
      state.board[r][c] = null;
    }
    // place created specials at their positions (if still empty)
    for(const s of createdSpecials){
      if(!state.board[s.r][s.c]){
        const tile = makeTile();
        tile.special = s.kind;
        state.board[s.r][s.c]=tile;
      }else{
        // if occupied, try to insert special above if possible
        for(let rr=s.r-1;rr>=0;rr--){
          if(!state.board[rr][s.c]){ const tile = makeTile(); tile.special = s.kind; state.board[rr][s.c]=tile; break; }
        }
      }
    }
    renderAll();
    beep(400 + chain*40, 0.06, 0.06);
    // after short delay, let tiles fall
    setTimeout(()=>{ gravity(); setTimeout(step, 220); }, 220);
  }
  step();
}

/* gravity: for each column, collapse nulls and generate new tiles on top */
function gravity(){
  for(let c=0;c<COLS;c++){
    let write = ROWS-1;
    for(let r=ROWS-1;r>=0;r--){
      if(state.board[r][c]){
        if(write !== r){
          state.board[write][c]=state.board[r][c];
          state.board[r][c]=null;
        }
        write--;
      }
    }
    // fill top with new tiles
    for(let r=write;r>=0;r--){
      state.board[r][c]=makeTile();
    }
  }
  renderAll();
}

/* ---------- ANIMATIONS (simple visual feedback) ---------- */
function playSwapAnim(r1,c1,r2,c2){
  // visual: briefly mark swapped tiles as selected then render
  state.selected = {r:r2,c:c2};
  renderAll();
  setTimeout(()=>{ state.selected = null; renderAll(); }, 160);
}

/* ---------- INPUT (tap/drag) ---------- */
let pointerDown = false, startCell = null;
boardEl.addEventListener('pointerdown', (e)=>{
  const el = e.target.closest('.cell');
  if(!el) return;
  const r = Number(el.dataset.r), c = Number(el.dataset.c);
  pointerDown=true; startCell={r,c};
});
boardEl.addEventListener('pointerup', (e)=>{
  pointerDown=false;
  const el = e.target.closest('.cell');
  if(!el) { startCell=null; return; }
  const r = Number(el.dataset.r), c = Number(el.dataset.c);
  if(!startCell) { startCell={r,c}; selectCell(r,c); startCell=null; return; }
  // if same cell -> toggle selection
  if(startCell.r===r && startCell.c===c){ selectCell(r,c); startCell=null; return; }
  // try swap if neighbor
  if(canSwap(startCell.r,startCell.c,r,c)){
    // if selected tile is a special and user wants to activate with swap? (this minimal impl treats swap normally)
    const swapped = doSwap(startCell.r,startCell.c,r,c);
    if(!swapped){
      // no match -> small feedback
      beep(220,0.05,0.03);
    }
  }else{
    selectCell(r,c);
  }
  startCell=null;
});
boardEl.addEventListener('click',(e)=>{
  // for tap-select (alternate)
  if(e.detail && e.detail>1) return;
  const el = e.target.closest('.cell'); if(!el) return;
  const r = Number(el.dataset.r), c = Number(el.dataset.c);
  selectCell(r,c);
});

/* selection/activation */
function selectCell(r,c){
  const cur = state.selected;
  if(!cur){ state.selected={r,c}; renderAll(); return; }
  if(cur.r===r && cur.c===c){ state.selected=null; renderAll(); return; }
  // attempt swap
  if(canSwap(cur.r,cur.c,r,c)){
    const swapped = doSwap(cur.r,cur.c,r,c);
    if(!swapped){ beep(220,0.05,0.04); state.selected=null; renderAll(); }
  }else{
    state.selected={r,c}; renderAll();
  }
}

/* ---------- BOOSTERS ---------- */
document.getElementById('boosts').addEventListener('click',(e)=>{
  const b = e.target.closest('button');
  if(!b) return;
  const which = b.dataset.boost;
  if(which==='hammer'){ useBooster('hammer'); }
  if(which==='shuffle'){ useBooster('shuffle'); }
});
function useBooster(name){
  if(state.boosts[name] <= 0){ alert('–ë—É—Å—Ç–µ—Ä –Ω–µ–¥–æ—Å—Ç—É–ø–µ–Ω'); return; }
  if(name==='hammer'){
    // pick random obstacle or random tile and remove
    let targetKey = null;
    const obKeys = Object.keys(state.obstacles);
    if(obKeys.length>0) targetKey = obKeys[randInt(obKeys.length)];
    else {
      // pick random tile and remove it (simulate broken)
      const r=randInt(ROWS), c=randInt(COLS);
      state.board[r][c]=null;
      gravity();
      processMatchesSequence();
    }
    if(targetKey){
      delete state.obstacles[targetKey];
      renderAll(); beep(720,0.08,0.08);
    }
  }else if(name==='shuffle'){
    // shuffle board tile types only
    const pool=[];
    for(let r=0;r<ROWS;r++) for(let c=0;c<COLS;c++){ if(state.board[r][c]) pool.push(state.board[r][c].type); }
    shuffleArray(pool);
    for(let r=0;r<ROWS;r++) for(let c=0;c<COLS;c++){ if(state.board[r][c]) state.board[r][c].type = pool.pop(); }
    renderAll(); beep(520,0.06,0.06);
  }
  state.boosts[name] = Math.max(0, state.boosts[name]-1);
  saveProgress();
}

/* ---------- LEVEL / PROGRESSION ---------- */
function checkLevelEnd(){
  const lvl = LEVELS[state.levelIndex];
  if(lvl.type==='score'){
    if(state.score >= lvl.target){
      levelWin();
      return;
    }
  } else if(lvl.type==='clear'){
    // count remaining obstacles
    const remain = Object.keys(state.obstacles).length;
    if(remain <= 0 || state.score >= lvl.target){ levelWin(); return; }
  }
  if(state.movesLeft <= 0){
    levelFail();
  }
}
function levelWin(){
  // calculate stars
  const lvl = LEVELS[state.levelIndex];
  let stars = 1;
  const ratio = state.score / lvl.target;
  if(ratio >= 1.6) stars = 3;
  else if(ratio >= 1.1) stars = 2;
  state.levelProgress[state.levelIndex] = Math.max(state.levelProgress[state.levelIndex]||0, stars);
  showModal('–£—Ä–æ–≤–µ–Ω—å –ø—Ä–æ–π–¥–µ–Ω!', `<p>–í—ã –ø–æ–ª—É—á–∏–ª–∏ ${stars} ‚≠ê</p><p>–û—á–∫–∏: ${state.score}</p>`, ()=>{ state.levelIndex = Math.min(LEVELS.length-1, state.levelIndex+1); initBoard(state.levelIndex); saveProgress(); closeModal(); });
  beep(880,0.18,0.12);
}
function levelFail(){
  state.lives = Math.max(0, state.lives - 1);
  saveProgress();
  if(state.lives <= 0){
    showModal('–ò–≥—Ä–∞ –æ–∫–æ–Ω—á–µ–Ω–∞', `<p>–£ –≤–∞—Å –∑–∞–∫–æ–Ω—á–∏–ª–∏—Å—å –∂–∏–∑–Ω–∏. –ü—Ä–æ–≥—Ä–µ—Å—Å —Å–æ—Ö—Ä–∞–Ω—ë–Ω.</p><p>–û—á–∫–∏: ${state.score}</p>`, ()=>{ state.lives = START_LIVES; state.levelIndex = 0; initBoard(state.levelIndex); saveProgress(); closeModal(); });
  }else{
    showModal('–ü—Ä–æ–≤–∞–ª', `<p>–£—Ä–æ–≤–µ–Ω—å –Ω–µ –ø—Ä–æ–π–¥–µ–Ω. –ü–æ—Ç—Ä–∞—á–µ–Ω–∞ –∂–∏–∑–Ω—å.</p>`, ()=>{ initBoard(state.levelIndex); closeModal(); });
  }
  beep(160,0.18,0.06);
}

/* ---------- UI: menu/modal/pause ---------- */
const overlay = document.getElementById('overlay'), modalContent = document.getElementById('modalContent');
function showModal(title, html, onOk){
  modalContent.innerHTML = `<h2>${title}</h2>${html}<div style="display:flex;justify-content:flex-end;margin-top:12px"><button class="btn" id="modalOk">–û–ö</button></div>`;
  overlay.classList.add('show');
  const ok = document.getElementById('modalOk');
  ok.focus();
  ok.onclick = ()=>{ if(onOk) onOk(); else closeModal(); };
}
function closeModal(){ overlay.classList.remove('show'); modalContent.innerHTML=''; }

/* menu */
document.getElementById('menuBtn').addEventListener('click', ()=>{
  showModal('–ú–µ–Ω—é', `<p class="smalltext">–£—Ä–æ–≤–µ–Ω—å ${state.levelIndex+1} ‚Äî ${LEVELS[state.levelIndex].name}</p>
  <p><button class="btn" id="menuRestart">–ü–µ—Ä–µ–∑–∞–ø—É—Å—Ç–∏—Ç—å —É—Ä–æ–≤–µ–Ω—å</button> <button class="btn" id="menuMain">–í –≥–ª–∞–≤–Ω–æ–µ –º–µ–Ω—é</button></p>
  <p class="smalltext">–ë—É—Å—Ç–µ—Ä—ã: –º–æ–ª–æ—Ç–æ–∫ ${state.boosts.hammer}, –ø–µ—Ä–µ–º–µ—à–∞—Ç—å ${state.boosts.shuffle}</p>`, ()=>{
    // default OK closes
    closeModal();
  });
  setTimeout(()=>{ document.getElementById('menuRestart').onclick = ()=>{ initBoard(state.levelIndex); closeModal(); }; document.getElementById('menuMain').onclick = ()=>{ state.levelIndex = 0; initBoard(0); closeModal(); }; }, 10);
});

/* restart/pause/sound */
document.getElementById('restartBtn').addEventListener('click', ()=>{ if(confirm('–ü–µ—Ä–µ–∑–∞–ø—É—Å—Ç–∏—Ç—å —É—Ä–æ–≤–µ–Ω—å?')) initBoard(state.levelIndex); });
document.getElementById('pauseBtn').addEventListener('click', ()=>{ showModal('–ü–∞—É–∑–∞', `<p>–ò–≥—Ä–∞ –Ω–∞ –ø–∞—É–∑–µ</p><p><button class="btn" id="resumeBtn">–ü—Ä–æ–¥–æ–ª–∂–∏—Ç—å</button></p>`, ()=>{closeModal()}); setTimeout(()=>{ document.getElementById('resumeBtn').onclick = ()=>{ closeModal(); }; },10); });
document.getElementById('soundToggle').addEventListener('click', ()=>{
  state.soundOn = !state.soundOn;
  document.getElementById('soundToggle').textContent = state.soundOn ? 'üîä' : 'üîá';
  saveProgress();
});

/* overlay click to close */
overlay.addEventListener('click',(e)=>{ if(e.target===overlay) closeModal(); });

/* ---------- INITIALIZE ---------- */
loadProgress();
initBoard(state.levelIndex);

/* autosave */
setInterval(()=>{ saveProgress(); }, 5000);

/* quick testing helpers (dev) */
// expose some functions to window for debugging in dev tools (optional)
window._m3 = {state, LEVELS, initBoard, saveProgress, loadProgress};

</script>
</body>
</html>
